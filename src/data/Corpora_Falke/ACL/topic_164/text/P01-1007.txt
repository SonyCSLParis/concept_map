1 Introduction
Usually, during a nondeterministic process, when a nondeterministic choice occurs, one explores all possible ways, either in parallel or one after the other, using a backtracking mechanism. In both cases, the nondeterministic process may be assisted by another process to which it asks its way. This assistant may be either a guide or an oracle.
An oracle always indicates all the good ways that will eventually lead to success, and those good ways only, while a guide will indicate all the good ways but may also indicate some wrong ways. In other words, an oracle is a perfect guide (Kay, 2000), and the worst guide indicates all possible ways. Given two problems �� and ��� and their respective solutions �� and ��� , if they are such that �� ������ , any algorithm which solves � is a candidate guide for nondeterministic algorithms solving ��� . Obviously, supplementary conditions have to be fulfilled for �� to be a guide. The first one deals with relative efficiency: it assumes that problem �� can be solved more efficiently than problem � � . Of course, parsers are privileged candidates to be guided. In this paper we apply this technique to the parsing of a subset of RCLs that are the languages defined by RCGs. The syntactic formalism of RCGs is powerful while staying computationally tractable. Indeed, the positive version of RCGs [PRCGs] defines positive RCLs [PRCLs] that exactly cover the class PTIME of languages recognizable in deterministic polynomial time. For example, any mildly context-sensitive language is a PRCL.
In Section 2, we present the definitions of PRCGs and PRCLs. Then, in Section 3, we design an algorithm which transforms any PRCL � into another PRCL �� , �ﬀ�ﬁ�ﬂ such that the (theoretical) parse time for �ﬂ is less than or equal to the parse time for � : the parser for � will be guided by the parser for �ﬂ . Last, in Section 4, we relate some experiments with a wide coverage tree-adjoining grammar [TAG] for English.
2 Positive Range Concatenation Grammars
This section only presents the basics of RCGs, more details can be found in (Boullier, 2000b).
A positive range concatenation grammar [PRCG] ﬃ � �"!$#&%'#)(*# � # � is a 5-tuple where !
!
is the start predicate name, and � is a finite set of clauses
-*.0/1-
�23232
-�4
#
8 �:9
+
!
�E%ﬁFG(H &I
, CKJML�JNA , is an argument. Each occurrence of a predicate in the LHS
(resp. RHS) of a clause is a predicate definition (resp. call). Clauses which define predicate name
�
<WV
T\[&]Z^
I fgmon
: L is its lower bound, f is its upper bound and fGp
L is its size. For a given _ , the set of all ranges is noted q n
<Ws and j:P?2l2wv mon and P are equal, the result is the range jELk2l2wv m n
�E%xFN(H &I can be instantiated to ranges. However, an occurrence of the terminal y can be instantiated to the range j fHp
CZ2l2 fgmon iff yz�{a|t . That is, in a clause, several occurrences of the same terminal may well be instantiated to different ranges while several occurrences of the same variable can only be instantiated to the same range. Of course, the concatenation on strings matches the concatenation on ranges.
We say that 8 �"}
8 �:9
CKJML�J
A and each symbol (terminal or variable) of 9 < , CJxL�JA is instantiated to a range in q n is instantiated to }d<
. If, in a clause, all predicates are instantiated, we have an instantiated clause.
A binary relation derive, denoted  �

/
,
�
�
ﬃ
, the PRCL defined by a PRCG ﬃ , is the set of all its sentences.
For a given sentence _ , as in the context-free [CF] case, a single complete derivation can be represented by a parse tree and the (unbounded) set of complete derivations by a finite structure, the parse forest. All possible derivation strategies (i.e., top-down, bottom-up, . . . ) are encompassed within both parse trees and parse forests.
A clause is:  combinatorial if at least one argument of its
RHS predicates does not consist of a single variable;  bottom-up erasing (resp. top-down erasing) if there is at least one variable occurring in its RHS (resp. LHS) which does not appear in its LHS (resp. RHS);  erasing if there exists a variable appearing only in its LHS or only in its RHS;  linear if none of its variables occurs twice in its LHS or twice in its RHS;  simple if it is non-combinatorial, nonerasing and linear.
These definitions extend naturally from clause to set of clauses (i.e., grammar).
In this paper we will not consider negative RCGs, since the guide construction algorithm
�
RXﬃYR
�� time. The exponent  , called degree of ﬃ , is the maximum number of free (independent) bounds in a clause. For a non-bottom-uperasing RCG,  is less than or equal to the maximum value, for all clauses, of the sum A [xZ[ where, for a clause Q , A [ is its arity and [ is the number of (different) variables in its LHS predicate.
3 PRCG to 1-PRCG Transformation Algorithm
�
�"!
#&%
#)(
#
��
#
�� be the generated 1-PRCG. Informally, to each A -ary predicate name
. We define !
�
�
%
,
(
��
(
, �� ��¡� and the set of clauses �� is generated in the way described below.
We say that two strings 9
¢
�¤

-*.¦/ -
.
#
<
<
). As an example, the following set of clauses,

µ
I
�
�
8 �"ºd#kºd#kº / º
�
8 »Z�"ºu / º
It is not difficult to show that �ﬀ�ﬁ�ﬂ . This transformation algorithm works for any
PRCG. Moreover, if we restrict ourselves to the class of PRCGs that are non-combinatorial and non-bottom-up-erasing, it is easy to check that the constructed 1-PRCG is also non-combinatorial and non-bottom-up-erasing. It has been shown in (Boullier, 2000a) that non-combinatorial and nonbottom-up-erasing 1-RCLs can be parsed in cubic time after a simple grammatical transformation. In order to reach this cubic parse time, we assume in the sequel that any RCG at hand is a noncombinatorial and non-bottom-up-erasing PRCG.
However, even if this cubic time transformation is not performed, we can show that the (theoretical) throughput of the parser for �� cannot be less than the throughput of the parser for � . In other words, if we consider the parsers for � and �� and if we recall the end of Section 2, it is easy to show that the degrees, say  and g , of their polynomial parse times are such that  J¼ . The equality is reached iff the maximum value  in ﬃ is produced by a unary clause which is kept unchanged by our transformation algorithm.
The starting RCG ﬃ is called the initial grammar and it defines the initial language � . The corresponding 1-PRCG ﬃ¸ constructed by our transformation algorithm is called the guiding grammar and its language �� is the guiding language.
If the algorithm to reach a cubic parse time is applied to the guiding grammar ﬃ¸ , we get an equivalent ��»
��»
-guiding parser. The output of a ( � » -) guiding parser is called a ( � » -) guiding structure. The term guide is used for the process which, with the help of a guiding structure, answers ‘yes’ or ‘no’ to any question asked by the guided process. In our case, the guided processes are the RCL parsers for � called guided parser and ��»
-guided parser.
4 Parsing with a Guide
� »
»
-guiding structure is then translated into a guiding structure, as if the source text had been parsed by the guiding parser. Second, the guided parser proper is launched, asking the guide to help (some of) its nondeterministic choices.
Our current implementation of RCL parsers is like a (cached) recursive descent parser in which the nonterminal calls are replaced by instantiated predicate calls. Assume that, at some place in an RCL parser,
� is an instantiated predicate call. In a corresponding guided parser, this call can be guarded by a call to a guide, with
�"}
�
�"}
� are instantiated predicates in the guiding structure. Of course, various actions in a guided parser can be guarded by guide calls, but the guide can only answer questions that, in some sense, have been registered into the guiding structure. The guiding structure may thus contain more or less complete information, leading to several guide levels.
For example, one of the simplest levels one may think of, is to only register in the guiding structure the (numbers of the) clauses of the guiding grammar for which at least one instantiation occurs in their parse forest. In such a case, during the second phase, when the guided parser tries to instantiate some clause Q of ﬃ , it can call the guide to know whether or not Q can be valid. The guide will answer ‘yes’ iff the guiding structure contains the set « [ of clauses in ﬃH generated from Q by the transformation algorithm.
At the opposite, we can register in the guiding structure the full parse forest output by the guiding parser. This parse forest is, for a given sentence, the set of all instantiated clauses of the guiding grammar that are used in all complete derivations. During the second phase, when the guided parser has instantiated some clause Q of the initial grammar, it builds the set of the corresponding instantiations of all clauses in « [ and asks the guide to check that this set is a subset of the guiding structure.
During our experiment, several guide levels have been considered, however, the results in Section 5 are reported with a restricted guiding structure which only contains the set of all (valid) clause numbers and for each clause the set of its LHS instantiated predicates.
%
I
%
I
. Thus, from a practical point of view the question is simply “will the time spent in the guiding parser and in the guide be at least recouped by the guided parser?” Clearly, in the general case, no definite answer can be brought to such a question, since the total parse time may depend not only on the input grammar, the (quality of) the guiding grammar (e.g., is �ﬂ not a too “large” superset of � ), the guide level, but also it may depend on the parsed sentence itself. Thus, in our opinion, only the results of practical experiments may globally decide if using a guided parser is worthwhile .
Another potential problem may come from the size of the guiding grammar itself. In particular, experiments with regular approximation of
CFLs related in (Nederhof, 2000) show that most reported methods are not practical for large CF grammars, because of the high costs of obtaining the minimal DFSA.
In our case, it can easily be shown that the increase in size of the guiding grammars is bounded by a constant factor and thus seems a priori acceptable from a practical point of view.
The next section depicts the practical experiments we have performed to validate our approach.
5 Experiments with an English Grammar
In order to compare a (normal) RCL parser and its guided versions, we looked for an existing widecoverage grammar. We chose the grammar for English designed for the XTAG system (XTAG, 1995), because it both is freely available and seems rather mature. Of course, that grammar uses the TAG formalism.1 Thus, we first had to transform that English TAG into an equivalent RCG. To perform this task, we implemented the algorithm described in (Boullier, 1998) (see also (Boullier, 1999)), which allows to transform any TAG into an equivalent simple PRCG.2
However, Boullier’s algorithm was designed for pure TAGs, while the structures used in the XTAG system are not trees, but rather tree schemata, grouped into linguistically pertinent tree families, which have to be instantiated by inflected forms for each given input sentence. That important difference stems from the radical difference in approaches between “classical” TAG parsing and “usual” RCL parsing. In the former, through lexicalization, the input sentence allows the selection of tree schemata which are then instantiated on the corresponding inflected forms, thus the TAG is not really part of the parser. While in the latter, the (non-lexicalized) grammar is precompiled into an optimized automaton.3
Since the instantiation of all tree schemata 1We assume here that the reader has at least some cursory notions of this formalism. An introduction to TAG can be found in (Joshi, 1987).
2We first stripped the original TAG of its feature structures in order to get a pure featureless TAG.
3The advantages of this approach might be balanced by the size of the automaton, but we shall see later on that it can be made to stay reasonable, at least in the case at hand.


.  spu-punct spus-punct 
”, and, in a second phase, this sequence is used as actual input to our parsers. The names between braces are pre-terminals. We assume that each terminal leaf v of every elementary tree schema ½ has been labeled by a pre-terminal name of the form yi�¿¾ -
QÀ
- LÁ where ¾ is the family of ½ , Q is the category of v (verb, noun, . . . ) and L is an optional occurrence index.4
Thus, the association George “  n-n nxn-n nn-n 
” means that the inflected form “George” is a noun (suffix -n) that can occur in all trees of the “n”, “nxn” or “nn” families (everywhere a terminal leaf of category noun occurs).
Since, in this two-step process, the inputs are not sequences of terminal symbols but instead simple DAG structures, as the one depicted in Figure 1, we have accordingly implemented in our RCG system the ability to handle inputs that are simple DAGs of tokens.5
In Section 3, we have seen that the language � defined by a guiding grammar ﬃ for some RCG ﬃ , is a superset of � , the language defined by ﬃ . If ﬃ is a simple PRCG, ﬃ¸ is a simple 1-PRCG, and thus �� is a CFL (see (Boullier, 2000a)). In other words, in the case of TAGs, our transformation algorithm approximates the initial tree-adjoining language by a CFL, and the steps of CF parsing performed by the guiding parser can well be understood in terms of TAG parsing.
The original algorithm in (Boullier, 1998) performs a one-to-one mapping between elementary trees and clauses, initial trees generate simple unary clauses while auxiliary trees generate simple binary clauses. Our transformation algorithm leaves unary clauses unchanged (simple unary clauses are in fact CF productions). For binary 8
-clauses, our algorithm generates two clauses, 4The usage of Â as component of Ã is due to the fact that in the XTAG syntactic dictionary, lemmas are associated with tree family names.
5This is done rather easily for linear RCGs. The processing of non-linear RCGs with lattices as input is outside the scope of this paper.
0 George 1
Figure 1: Actual source text as a simple DAG structure an 8
-clause which corresponds to the part of the auxiliary tree to the left of the spine and an
�
- clause for the part to the right of the spine. Both are CF clauses that the guiding parser calls independently. Therefore, for a TAG, the associated guiding parser performs substitutions as would a TAG parser, while each adjunction is replaced by two independent substitutions, such that there is no guarantee that any couple of tree can glue together to form a valid (adjoinable) 8
-tree. In fact, guiding parsers perform some kind of (deep-grammar based) shallow parsing.
�
»
- guiding grammar. Table 1 gives some information on these grammars.6
RCG initial guiding �
%
R 476 476 476 R ��R 1 144 1 696 5 554 RXﬃÄR 15 578 15 618 17 722 degree 27 27 3
Table 1: RCGs ﬃ·� �"!$#&%'#)(*# facts
For our experiments, we have used a test suite distributed with the XTAG system. It contains 31 sentences ranging from 4 to 17 words, with an average length of 8. All measures have been performed on a 800 MHz Pentium III with 640 MB of memory, running Linux. All parsers have been
6Note that the worst-case parse time for both the initial and the guiding parsers is Å0ÆlÇ@È"ÉËÊ . As explained in Section 3, this identical polynomial degrees ÌÍ Ì|Î�ÍÏbÐ comes from an untransformed unary clause which itself is the result of the translation of an initial tree.
compiled with gcc without any optimization flag. We have first compared the total time taken to produce the guiding structures, both by the � »
-
� »
�
»
�
�ËÑ
-guiding parser and besides we have verified that the even crossing point seems to occur for sentences of around 16– 20 words.
parser guiding �
35-word sent. 30.560 5.210 parser load module initial 3.063 guided 8.374 �
»
Table 3: RCL parser sizes (MB)
»
Table 4: Parse times (sec)
The sizes of these RCL parsers (load modules) are in Table 3 while their parse times are in Table 4.7 We have also noted in the last line, for reference, the times of the latest XTAG parser (February 2001),8 on our sample set and on the 35-word sentence.9
6 Guiding Parser as Tree Filter
In (Sarkar, 2000), there is some evidence to indicate that in LTAG parsing the number of trees selected by the words in a sentence (a measure of the syntactic lexical ambiguity of the sentence) is a better predictor of complexity than the number of words in the sentence. Thus, the accuracy of the tree selection process may be crucial for parsing speeds. In this section, we wish to briefly compare the tree selections performed, on the one hand by the words in a sentence and, on the other hand, by a guiding parser. Such filters can be used, for example, as pre-processors in classical [L]TAG parsing. With a guiding parser as tree filter, a tree (i.e., a clause) is kept, not because it has been selected by a word in the input sentence, but because an instantiation of that clause belongs to the guiding structure.
The recall of both filters is 100%, since all pertinent trees are necessarily selected by the input words and present in the guiding structure. On the other hand, for the tree selection by the words in a sentence, the precision measured on our sam-
7The time taken by the lexer phase is linear in the length of the input sentences and is negligible.
8It implements a chart-based head-corner parsing algorithm for lexicalized TAGs, see (Sarkar, 2000). This parser can be run in two phases, the second one being devoted to the evaluation of the features structures on the parse forest built during the first phase. Of course, the times reported in that paper are only those of the first pass. Moreover, the various parameters have been set so that the resulting parse trees and ours are similar. Almost half the sample sentences give identical results in both that system and ours. For the other half, it seems that the differences come from the way the co-anchoring problem is handled in both systems. To be fair, it must be noted that the time taken to output a complete parse forest is not included in the parse times reported for our parsers. Outputing those parse forests, similar to Sarkar’s ones, takes one second on the whole sample set and 80 seconds for the 35-word sentence (there are more than 3 600 000 instantiated clauses in the parse forest of that last sentence).
9Considering the last line of Table 2, one can notice that the times taken by the guided phases of the guided parser and the Ç~Ó -guided parser are noticeably different, when they should be the same. This anomaly, not present on the sample set, is currently under investigation.
ple set is 15.6% on the average, while it reaches 100% for the guiding parser (i.e., each and every selected tree is in the final parse forest).
7 Conclusion The experiment related in this paper shows that some kind of guiding technique has to be considered when one wants to increase parsing efficiency. With a wide coverage English TAG, on a small sample set of short sentences, a guided parser is on the average three times faster than its non-guided counterpart, while, for longer sentences, more than one order of magnitude may be expected.
However, the guided parser speed is very sensitive to the level of the guide, which must be chosen very carefully since potential benefits may be overcome by the time taken by the guiding structure book-keeping procedures.
Of course, the filtering principle related in this paper is not novel (see for example (Lakshmanan and Yim, 1991) for deductive databases) but, if we consider the various attempts of guided parsing reported in the literature, ours is one of the very few examples in which important savings are noted. One reason for that seems to be the extreme simplicity of the interface between the guiding and the guided process: the guide only performs a direct access into the guiding structure. Moreover, this guiding structure is (part of) the usual parse forest output by the guiding parser, without any transduction (see for example in (Nederhof, 1998) how a FSA can guide a CF parser).
As already noted by many authors (see for example (Carroll, 1994)), the choice of a (parsing) algorithm, as far as its throughput is concerned, cannot rely only on its theoretical complexity but must also take into account practical experiments. Complexity analysis gives worst-case upper bounds which may well not be reached, and which implies constants that may have a preponderant effect on the typical size ranges of the application.
We have also noted that guiding parsers can be used in classical TAG parsers, as efficient and (very) accurate tree selectors. More generally, we are currently investigating the possibility to use guiding parsers as shallow parsers.
The above results also show that (guided) RCL parsing is a valuable alternative to classical (lexicalized) TAG parsers since we have exhibited parse time savings of several orders of magnitude over the most recent XTAG parser. These savings even allow to consider the parsing of medium size sentences with the English XTAG.
�������
� »
-guiding parser processing short sentences.
We must also note that a (guided) parser may also be used as a guide for a unification-based parser in which feature terms are evaluated (see the experiment related in (Barthe´lemy et al., 2000)).
Although the related practical experiments have been conducted on a TAG, this guide technique is not dedicated to TAGs, and the speed of all PRCL parsers may be thus increased. This pertains in particular to the parsing of all languages whose grammars can be translated into equivalent PRCGs — MC-TAGs, LCFRS, . . .
