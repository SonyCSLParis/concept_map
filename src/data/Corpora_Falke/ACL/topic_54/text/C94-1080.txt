1 INTRODUCTION
In this paper, we propose a grammar model that combines lexical organization of grammatical knowledge with lexicalized control of the corresponding parser in a coherent object-oriented specification framework. We build upon recent developments in the lield of linguistic grammar theory which have already yiekled a rigid lexical mod,larization, but extend thcm by assigning full procedural autonomy to lexical units. In particular, we treat lexic,'ll items as active lexieal processes commtnticating with each other by message passing. Titus, they dynamically establish heterogeneous communication lines in order to dctcnninc each lexical item's fimctional role. While the issue of lexiealize(I control has early becn invcstigatcd in the l)aradigm of conceptual parsers (e.g., Riesbcck & Schank 1978), and word expell parsing in particular (Small & Ricger, 1982), we here elaborate on improving ils lcxical commtmication facilities by formalizing the parscr's message passing protocol according to actor computation principles. As this protocol allows for asynchronous message passing, concurrency enters as a theoretical notion at the level of grantmar specification, not only as an implcmentational fcatttrc. Correspondingly, we introduce a behavioral description in terms of event type networks which rcpresent grammatical interrelations at the level of actor definitions, while event networks represent the I)arsing process in terms of actual messages exchanged between instantiated actors. The ParseTalk model outlined in this paper can thereft)re be considcred as an attempt to rcmedy the lack of theoretical integration of parallelism at the level of grammar design.
2 ParseTalk's GRAMMAR MODEL
The ParseThlk grammar mcxlel (of. Br6kcr, Hahn & Schacht (1994) for a more comprehensive treatment) considers dependency relations between words as the fundameatal notion of lingnistic analysis. This corresponds to the head-orientation found in most modern grammar theories. Grammatical spccilications are given in the format of valency constraints attached to each lexical unit, on which lhe comptttalion of concrete dependency relations is based. A modilicr is said to depend on its head if the modifier satisfies the constraints placed on it. These constraints incorl×)rate iulormation about the hierarchy of word classes (encapsulating declarative and behavioral properties of lexical items), nmrphosyntax (containing Ihe grammalical conditions of the combination of lcxical items to l)hrascs as expressed by a unification [ormalism, similar to Shieber, 1986), linear ordering (stating precedence relations between a head and its modiliers), and permitted conceptnal roles (expressed in terms of a hybrid, classilication-based knowledge represenlation formalism; cf. Mac- Gregor, 1991). Dependencies are thus asymmelric binary relations that can be established by local computations involving only two lexical items 1 and simnllaneonsly lake grammatical as well as conceptual well-formedness criteria into account.
P,y way of inheritance (for a rcccnt survey of apl)lying inheritance mechanisms in modern gramlnar theory, of. l)aclemans, I)e Sine(It & Gazdar, 1992) the cnlirc collection of lexical items is nrganizc(l in a lexieal hierarchy, the lexical items forming its leaves and the intermediary nodes representing grammatical generalizations in terms of word classes. This form of specification is similar to variotts proposals currently investigated within the unification grammar connnunity (e.g., Evans & Gazdar, 1990).
t We exlend this definition to incoqxmLtc the notion of phrases as well. Ahhough phrases are not explicitly represenled (c,g., by non-lexical categories), we consider each complete suhtrce of Ihe delx~ndency tree a phrase (Ihis definition allows discontinuous phrases as well). A dependency is thus not trealed a~: a relation between words (as in Word Grammar (lludson, 199(], p.1171, but between a word and a dependent phrase (as in l)epcndency Unification (]rammar (llellwig, 1988)). The root of a phrase is taken to be the rel~resent:ttlve of tim whole phrase,
3 ParseTalk 's COMPUTATION MODEL
Although the object-oriented pm-adigm seems to bc well suitexl to support the distribution of data through encapsulation and the distribution of control via message passing, most object-based calculi rely on synchronous messages and dmrcfore do not provide for concurrency. One of the few exceptions that aim at the methodologically clean combination of object-oriented features with concurrency and distribution is the actor model of computation (Agha & Hewitt, 1987). It assumes a collection of independent objects, the actors, communicating via asynchronous, point-to-point message passing. All messages art guaranteed to be delivered and processed, but in an unpredictable order and indeterminate time. Each actor has an identity (its mail address), a state (consisting of the addresses of its acquaintances, i.e., the set of other actors it may send messages to) and a behavior (i.e., its reaction to incoming messages). Tile arrival of it message at an actor is called an event; it triggers an action described by the corresponding method definition, a composition of the following atomic actions: creating a new actor (create actorType (acquaintances)); sending a message to an acqtminted or a newly created actor (send actor message); or specifying new acquaintances for itself (become (acquaintances)). An actor system is dynamic, since new actors can be created and the communication topology is reconfignrable in the course of actor computations.
The actor model does not contain synchronization primitives, but we assume one-at-a-time serialized actors for our specification, i.e., actors that cannot process more than out message at a time and that process each message step by step (cf. Hcwitt & Atkinson (1979) for expressing this convention in terms of patterns of simple actors). The distribution of comlmtation among the collection of actors is dins dm only source of parallelism. Furthermore, in order to compute complex, but well understo~x[ and locally determined linguistic conditions and functions, such as unification of feature structures iuld queries sent to a (conceptual) knowledge base, we esud)Iish a synchronous request-reply protocol (of. Licberman, 1987).
The ParseTalk model extends Ihe formal foundalkms of the basic actor model according to the requirements set up by tilt natural language processing application. These extensions are expressible by the primitives of the basic model. We distinguish between word actors, relations between word actors and a special set of messages word actors exchange.
• Word Actors: The grammatical knowledge associated with each lexieal item is represented in a word actor definition. Upon instantiation of a specific word actor, d~e acquaintances specilied in the definition will be initialized with actors which stand for the lexical item's morphosyntactic features, its conceptu,'d representation, valency constraints and, after instantiation and subsequent parsing events, governed lexical items and further grammatical relations (e.g., adjacency, textual relations).
• Word actor relations: Acquainumces of word actors are tagged according to linguistic criteria in order to serve as navigation aids in linguistic structures (the message distribution mechanism described below). Textual relations, e.g., are distinguished from linear adjacency and hierarchical dependency relations. Tagging imposes a kind of typing onto acquaintances that is missing in odmr actor systems.
• Word actor messages: In contrast to simple messages which unconditionally trigger the execution of the corresponding method at the receiving actor, we define complex word actor messages as full-lledgcd actors with independent computational capabilities. Departure and arrival of complex messages are actions which are performed by the message itself, laking the sender and the target actors as parameters. Upon arrival, ,'~ complex message determines whether a copy is forwarded to selected acquaintances of its receiver and whether the receiver may process the message on its own. Hence, we redefine an arrival event to be an uninterruptable sequence of a computation event and distribution events. The computation event corresponds to an re'rival of a simple message at the receiving word actor, i.e. an event in the basic model; it consists of the execution of an actor's lee(hod that may change the actor's state and trigger additional messages. The distribution events provide for the lorwarding of the message and are realized by cre,qtiug new complex mess.ages. They depend on the (unchanged) state of the receiving actor or on the result of the computation event and take place before and after the computaliou event. This extension accounts for the complexity of interactions I)ctween word actors.
We define tl~c semantics of an actor program in terms of two kinds of networks. First, we consider event types which refer to message keys and can easily be determined from ,'1 given actor program. Next, we turn to actual events that involve instantiated actors. Both, event types and events, arc partially ordered by the transitive closures of relations alll()ng them, causes t and causes, resp., that give rise to event type networks and event networks.
A program (in our apl)lication: a lexical grammar) is given by a set of actor d@nitions. The definition characlerizcs the type ()1" an actor. Given a program, event types, written as I* <- key], can be syntactically deterlnined by inspecting the method delinitions wilhin the program. Let an actor type aName I)e defined by:
.£kelg£J.~ aName (acquaintance 1 ... acquaintancek) meth key 1 (param 1 ... paramrn ) (action1) . . .
meth key n (param 1 ... paraml) (actionn) with action i delincd by the following grammar fragment: action ::= action; action ] if condition (action) [ ~ (action) ] I .keJ3£L actor messageKey ( param* ) ] becom_____~e ( acquaintance* )
Wc may now map message keys to sets of message keys, defining the function sctipt~,r~zm e as follows: scriptaA(ome (keYi) = send(action!) with sent{(action) := {msgKey } if action = send actor msgKoy (param, ...) setu{(al) u sertd{a2) if action = [[ condition a I else a 2 sent{(al) if action = if condition a 1 sentf((at) u senaC(a2) if action = a l ; a2 else
For a program P, script is the union of all given script,m,, e with name e { aroma I P contains a delinition for aNamo } and yields a set containing the keys of those messages that can be provoked by a ,nessage with the key mKey. Now, a relation between event types is delined hy causes!:
([* ¢= mKey], [* ¢=- nKey]) < cat tses t
:<=> nKey ~ scrit)t(mKey ).
Turning to actual events now, we define an actor a/as being composed of an identity n (taken from lhe set of natural numbers, N), a state e Sand a behavior e 9{. l lence, .9/, the set of actors, is a subset of N x S x O~.
,5 = 2 { (y: z,) ly is an identifier, z e A] , an element of`5 associates acqna in tance names and va lues , wh ich are actors . Since actors change their acquaintances, their state is valid in lime, i.e. lit a par t i cn la r event . The state o f an ac tor a. receiving a message m will be written as S¢l a <= ml' Slate changes caused by the message apply at the end of the event [a <=- m] (by executing a become action).
q# is a set of fnnetions, delhted as folk>ws: The state s<, e of an lictor ,X'flt tile event e (the reception of a mc.ssage m) is determined by iL,; initial state given after its creation event, arid the repeated application of its state transition function, transit~c, which maps pairs of stales (s c S) and messages (m ~ 9¢1 c .90 to new slates: tra,sitx: (`5 x 9t4} -> ,5
The sand actions an actor ,1" perlk)rms at a partictflar event are expressed as pairs of target actors and messages to be sent; the target actors are either ,'lcqnainlances o[" the sending actor or supplied as message parluneters. They are determined by the function task~ (,5 x Ov 6 -> 2 (m('q) × ~6 where ~l(N) denotes the projection onto the first compo- !tent of N, viz. N.
The behavior of an actor A'can then be stated by the function be~ar;e~Ce q~ that comhines transit,@nd tas~.,,f.in that it maps pairs of suites and messages to pairs consisting of the new slate of the actor and a set of pairs of target actor identities and ,nessages, viz., bebave~: (S x 9v~ -> ( S x 2 (Tq(& x 94)).
Abstracting from a local actor perspective the behavior of an entire actor system (in our applicatkm: lhe lexical parser composed of a collection of word actors) is determined by the way multiple events are related under Ihe causes relation (though events are written as [actor <=
,nessagel, the message key is used as an abbreviation for the messages in Section 5):
( [a~ nil, [,6<=- hi)< ca,ses
:¢~ (Xl(&, '0 e tasfCa(Sa,[a~ ml, "0.
Event.'.; that ;ire not ordered by the transitive closure of causes can take place in parallel or, if they refer to the same lictor, ill an arbitrary order.
4 EVENTTYPE NI . , ;TWORK SPECIF ICAT ION OF A GRAMMAR FRAGMENT
The protocol (messages and associated actions) for establishing dependencies on!lined below encodes structural restrictions of the dependency structure (projectivity), ensures incremental general!on of dependency trees, and provides a domesticated fornl of concurrency.
Consider a newly instantiated word actor wn (cf. Fig. 1) se,'!rching bottom-up for its head by sending a search- Head message to its immediate left neighbor, w,. l. The searchHead message is recursivcly forwarded by a sequence of distrihution events to the head of each receiving actor (i.e., w,,_ I, w k, wj); mess,'lges only p.'lss the outer fringe of the already eslablished dependency tree (these am circled in lvig.1). Since only the actors receiving the searchHead message may later govern w n, projective trees are generated 2.
""X -~- - - searchHead ]
¢'i ~ ....... % I;iflure l, [:olwarding a search message
To allow for domesticated concurrency as required for adequate linguistic and cognitive processing (Clark & Gibson, 1988), a receipt protocol allows w n to keep track of all events (transitively) caused by its searchHead message. This protocol requires each actor receiving a search- Head message to reply Io the initiator of the searchHead message hy a receipt message when the receivers compulalion has linished 3. Since complex messages can be quasi-recursively forwarded, the number of replies cannot be determined in advance. Therefore, the receipt message contains all actors to which the searchHead message has been dislrihnted, enabling the initiator w n to keep Irack of all receivers and wait for a receipt message from each 4. Only after all events caused by the searchHead message have terminated, the next word actor w,,~l is instantiated by sendiag a scanNext message to the text scanning actor.
2 Of coutse w may be l, ovemed by any word actor govemhlg w. lml ' ' I1 J ,p due (o Ih¢ incremenlality of the analysis, each head c,f wj must Im hx!ated to Ihe right of w n.
3 Note Ihat "eom[]tllalioll" here may irldlltIe a tll.llllbef of evetlls Lhat are caused by Ihe soarchHoad message, viz. the hoadFound and hoadAacopted messages described below.
,I We plall I0 extend our algolilhm It, a gCllefic [efl1"litla|[olI dcteclion scheme similar to tim proposal in Shavit & France;,,, 1986.
I I'1O Cotlslrailll / I conxtraml I / ..~./;~o~,, t [satisf ied / [ ..... ;",.~,,/ [ / . . . . . J~ '~J Istructural ]
... ~ . ~ ' ~ / l ambigm' ty J ~ ~ ,
L - " t. I )..,i,.. I • , • .- modijiers' j ( ,.<=-,.,,...,-o, j ]i<-.,,,o.. I..o..,, . . . . , , L'/J Figure 2. Event type network
Upon reception of a searchHead message, a word actor w k checks whether w n satisfies the couslraints for one of Wk'S valencies. If no constraints are satislied, a receipt message is sent back to signal termination of this particular event at w k. If w n may Iill a valency of w k, a headFound message is sent back to w,, thus possibly imposing additional grammatical restrictions on the targeted item. If w, is still ungoverned, it adjusts its grammatical description (and those of iLs modiliers, if necessary, by sending updateFoatures to each) and signals acceptance of the new head hy a headAccepted message directed to w k. These interrelations are sttmmarized in the event type network in Fig.2.
This three-step protocol allows ,qlternative attachmenL,; to be checked in parallel (concurrent processing of searchHead messages at different actors). Structural ambiguities are detected whenever a headFound message arrives at an actor w n which is already governed. In this case, w n duplicates itself and its modifiers (using the copyStrueture message), resulting in w,, and asks the prospective head to copy itself (hy sending a duplicateStructure message), w n becomes head of the copies of the modifiers of w n (because each is answering the copy- Structure message with a hoadAccepted message) and will be governed by the copy of the head (because the copy sends another headFound message to wn; for a more detailed discussion, of. Hahn, Schacht & BrOker, forthcoming).
The unpacked representation of antbiguity is necessary because of the simultaneous incorpor,'~tion of conceptual analysis into the parsing process. Difl'ercnt syntactic structures result in different conceptual analyses, which means fllat there is no common structure to share anymore (cf. Akasaka (1991) for a similar argument). The set of actors representing several readings of one lexical item can proceed concurrently, thus introducing further concurrency.
5 EVENT NETWORK SPECIF ICAT ION OF A SAMPLE PARSE
We will now consider a partM event network in order to illustrate the parse of "Compaq entwickelt einen Notebook mit einer 120-MByte-Hardd isk "5. At some point after reading the sentence, the configuration shown on I7ig.3 will h;tve been reached. The preposition [mit] 6 is not yet integrated due to a mandatory valency that must tm satislied prior to making conceptual restrictions available. Upon establishment of a corresponding dependency between Imit] and [ttarddisk] (Fig.3), [mit] slarts to search for its head. This search results in the dependency tree depicted on Fig.4.
enlwickelt entwickelt einer i Figure 4. After establishment of dependency
The events caused by the satisfaction of the mandatory valency at [mit] (headAecepted event at top left of Fig.5)
[mit] <= ileadAt:cepted ) l,'igure 5. Event network
5 A rough English translation of this reads as "Compaq develops a notebook with a 120-MByte haul divE'. Notice that from a syntactic perspeclive cilher Ihe verb "entwicla~lt" or the noun "Notebook" may take a preposilional phrase wifll "mlt" specifying an instrument or a part, resp. This |x~teutial stnlctural ambiguity dc~s not (recur in our m~xlel due to parallel evalualicm of constraints in different knowledge sources.
6 Word actors represenllng a lexical item "x" will be wrilten as [x].
are specified in tim event network in Fig.5. The dotted line indicates an alternative possibility how the seanNext event could have been triggered. Of the two receipt events, the last one taking place triggers the seanNext event (note that both involve the same actor, (mitt, so that they must be ordered, even in a distril)utcd system without global lime).
6 CONCLUSIONS
The ParseTalk model of natural language understanding aims at the integration of a lexically distributed, dependency-I)ased grammar Sl)CCification with a solid formal foundation for concurrent, object-oriented parsing. The associated concurrent compu~ttion model is based el} the actor paradigm of object-oriented programming, with several extensions relating to special reqtfirements of natura l langtmge processing. These cover mechanisms for complex message distribution, synchronization in terms of request-reply protocols, and the distinction of dislriht, tion and computation events. We have shown how the semantic specification of actor systems can be used for the consideration of global interrelatious of word actors at the grammar level (event type networks) and the parser level (event networks). While event type networks provide a general, global view on the behavioral aspects of ottr grannnar specification, the current formalism slill lacks the ability to stlPi)ort ret inal reasoning about computat iona l prope, rties of distributed systems, such as deadlock freeness, termination. On tim oflmr hand, event networks illustrate the contimtations during real parses, but do not allow predictions in general cases. Providing a type discipline for actor detinitions may Ix: a reasonable apl)roach to till the methodological gap between both layers of description.
The ParseT?flk model has been exlmritnentally vali.. dated by a prototype system, a parser for Germ;re. The current fifll-form lexicon contains a hierarchy of 54 wordclass specifications and nearly 1000 lexieal entries; a module for lnorphological analysis is trader development. The parser's coverage is currently restricted to the analysis of assertional sentences, with focus on complex noun and prepositional phrases. The Parse'l?flk system is impleinented in Smalltalk, with extensions that allow for coarsegrained parallelism through physic,'d distribution in a workstation cluster (Xu, 1993) and asynchronous ntessage passing. It is loosely coupled with lhe l.OOM knowledge representation system (MacGregor & Bates, 1987). We currently use a knowledge base with 120 concept delini- }ions covering the domain of information technology. Furthennore, an interactive graphical grammar/parser engineering workbench is supplied which supports the development and maintenance of the ParseTalk grammar sysleln.
