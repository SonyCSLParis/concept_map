1 Mot ivat ion Despite recent efforts in improving graph unification algorithms, graph unification renlains the most expensive part of parsing, both in t ime and space. ATR 's latest data fi'om the SL -TRANS large-scale speech-to-speech translation project ([Morimoto, et al, 1990]) show 80 to 90 percent of to t~ parsing t ime is still consumed by graph unification where 75 to 95 percent of t ime is consumed by graph copying funeti(ms. 1 Qu~si-Destruetive (Q-D) Graph Unification ([Tontabeehi, 1991]) was deveh)ped as a fiLst variation of non-destructive graph unification based upon the notion of t ime-sensit ive 'qu~mi-destruction' of node structures. The Q-D algorithm was proposed I)~Lsed upon the following m:cepted obserwttion about graph unification:
Uni f i ca t ion does not a lways succeed.
Copy ing is an expens ive operat ion .
The design of tit(', Q-D scheme was motiwttcd by the following two princil)les h~r frost gral)h unification ba,sed upon the above observations:
• Copy ing shou ld be per fo rmed on ly for success fu l un i f i cat ions .
• Un i f i ca t ion fa i lures shou ld be found as soon as poss ib le .
*This research wa.8 (lone while the author was ~ Visiting Research Scientist at ATR Interpreting Telephony [O~search Laboratories.
lBased on unpublished reports from Knowledge itnd Data Processing Dept. ATR. The observed tendency was that sentellCCS with very long parsing tillle requiting a large Ii|lltll~t~r of unification calls (over 200l} top-level calls) coll811lllcd extremely htrge proportion (over 93 percent) of total paraing time ft~r graph unification. Similar data tep0rted in [Kogure. 19901.
and el iminated Over Copying and Early Copying (as defined in [Tomabechi, 1991] 2) and ralt about twice the speed of [Wroblewski. 1987]'s algorithm, a In this pal)er we proi)ose another design principle f(n' graph unification bmsed upon yet another accepted observation that:
Unmodi f ied subgraphs can be shared .
At lemst two schelnes have been proposed recently ])a.~ed Ul)OU this observation (namely [Kogure. 1990] and [Emele, 1991]); however, both schemes are I)ased upon the increlllent'al Col)yiug sehellle all( l ~-LS ([escribed in [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi'om Early Copying as defined in that article. This is I)eeause, when a unification falls, the copies that were (:reated up to the point of failure are w~Lste(l if copies are created increment;ally, By way of definition we would like to categorize the sharing of struetul'eS in gral)hs into Feature- Structure Sharing (FS-Sharing) ~nd Data-Structure Sharing (DS-Sharing). Below arc our definitions:
• Feature -St ruc ture Shar ing : Two or more distinct i)~,ths within a graph share the same subgraph by (:onwwging (111 the same node equivalent to the notion of structure sharing or reenlrancy in linguistic theories (such ~ in [Pollard and Sag, 1987]).
• Data-St ruc ture Shar ing : Two or more distinct graphs share the same subgral)h by converging nil the same node the noti(m nf
2 Namely. • Over Copying: Two dags ate created in order to create one new dag, This typically happens when Col)its of two input d~tgs are created prior to a destructive unific~Ltion operation to build one new dag.
• Early Copying: Copies ar~ created prior to the failure of unification so that copies (:reltted since the beginning of the unitication up to the point of failure are wasted.
Wroblewski defined Early Col)ying as follows: "The argutnent dags are copied be/t~te unification started. If the unilication fails then some of the Ct)l)ying is wasted effort" attd restricts early copying to cases that only apply to copies that are created prior to a unification. Our definition ()f Early Copying includes copies that ~rc created during a unification and created up t() the point of fltilur(~ width were iltt(!ow~red by Wroblewski's definition.
3 Recent (~xp(~rilnents COlllhlctt~d ill the Knowledge all(] Data Pro(:esniug Dept. of ATR shows the original Q-D algorithm COllsiatelltly rllllS lit ~tt~out 40 ])q~rctrl|t ~ff the elal)sed tillle uf Wroblewski'8 algorithm with its SL-TRANS large-scale upoken-languag,~ ttansl~ttlon system (with over l(t00{I grammatical gral)h nodes).
ACRES DE COLING-92, NANTES, 23-28 AOt~T 1992 4 4 0 PROC, OF COLING-92, NANTES, AUG. 23-28, 1992 straeture-sharing at tim data structure level. [Kogurc, 1990] cldls Coltying of sui:h strltctures Redundant Copyin 9.
Virtually all gral~ll-lutitication alg(n'itlinl,,; suptmrt FS-Sh~triug and some SUliport DS-Sharing with varying levels (if overhead. In this lisper we proltOSl~ ~t sclienle of graph unification I)tmed UllOn a qu;~sidestrtt(:tive gratth uniti(:ati(m inetlloll that attains DS-Sharing with virtually no overh(',ad for structuresharing. Henceforth, in tills palter, structltre-sharing refers tit DS-sllariug unless otllerwise n(ited. Wc will see that tfic iutroducti(m of strlu:ture-sliarilag to qua~si-destructive imification art;tins another two-fold increase ill rim tiluc spired. The graphs llamdled in the scheme (:;tit lie auy dirc(:ted grai)ll and cycli(:ity is llaudled without any algorithmic ;tdditions.
Our design princiitles for achieving structlu'C- sharing in tit(', qlta.si-destructive scllellU~ are:
• Atomic and Bot tom nodes can be shared 4
Atomic nodes can lie sltarcd sahdy since they t lever cli~l, l l ge the i r wdues . B ( I t to l l l l l od l !s Cal l It(!
share(l 5 s i t tce bottom nodes are always fl)rwal'ded to somc other uo(Jes wllcn they unify.
• Complex nodes can be shared un less they are mod i f ied - conq)lex nodes (:all bc COllSldercd modified if they ~tre a target of the fitrwarding operation m' if riley received the curreut additiml of comltlcment arcs (into COml)-ari:-list in (pia,si-destructive sclmme).
By designing an algorithm ba.sed Ult,m these pril> (:il)les for strlu:ture-sliarillg while retaining the quasidestructive nature of [Totnat)echi, 1991]'s algoritllnl, our scllmnc eliniinates l{,cdlnt(tant Cllpying whih~ elinlinating botll Early Copying auld Over Copying.
2 Q-D Graph Unif icat ion We Woldd first like to describe tlle qu;Lsi-destructiwe (Q-D) graph unilication schenle which is the lnLsis of our s(:henl(,'. As a data structltrl~, at nolle is rcpre sentcd with live fiehls: type, arc-llst, comp ark-list. fm'w~u'd, (:oily, and geueration. 6 The data-structure for an at'(: has two liclds, qabel' and 'value'. "Lot)el" is an atmnic symt)ol wllicli labels tile ;u'e. and 'wdue" is a llointer to a l lo ( le structure.
The central notion of tile Q-D algm'itlun is tile del)eudency of the retiresentational (:ontcnt on the glob~d timing clol:k (or thc global counter for tlic currcnt generation of lUlific;~tions). Any luodilic;~tiol~ made to coml)-arc-list, forward, or i:Olly rid(Is during one top-lcw:l uniticati(m (:au bc inwdidated by (me in- (:renlent otmration inl tile global t imiug counter. COIl tents of the (xmlp-arc-list, forward and (:opy fields arc
' IAtomic lto([l~8 ;ire IlodeH (halt reprea(~llt atoluic vcdue8, l i e ( lo in nodes are llo{|e8 that repreuellt var iabh* .
~As long as the unific~ttion Ol)er,~tion is the only operation to nmdify graphs.
6 Note that [Tonlabechi, 1991] used sellarttte lltark fields fin COml)-;trc-liat, forward, fill(| copy: (:urrently however, (}lily f}lltt general(kin mark is used for adl three fiehls. Thanks are due to Hidehiko M~U,uo of T,)yo Informattion Sy,tcms (TIS) for suggesting thin.
NODE type + . . . . . . . . . . . . . . . + comp-nrc - l in t + . . . . . . . . . . . . . . . +
Figure 1: Node and Arc S t ructures resl)cctc(l ,rely wlten tile ge.neration mark of the lml'- ticlll~u' node nuttches tile current glob;d comat.er wdue. Q-I) graph unificatiola ham two kinds of arc lists: 1) ar,:-list and 2) colnt~;u'c-list. Arc-list (:Ollt~tins the arcs that are p(!rln;tu(!nl (i.e.. ordimLry gral)li arcs) and Cillnp-arc list contains arcs that are rally wdid during one top-hwel graph unitication oper;d, ion. Tim algorittun also uses two kintls of fi)rwardlng links, i.e,, l ) (!rtt la lal!nt ;IAl(l t;(!llll)Ol'&l'y, i l l(!rl l l~l, l lel lt fo rwar ( f i l l g link is the usual fm'warding link ftnmd in ottler' ;dgoritfilns ([Pereir~t, 19851, [Wroblewski. 1987], ctc). Telnl)orary forwarding links arc links tlud. arc only wdid during onc top-level unilic~tti(m, Tlic currency IIf the temporary links is (letermiued by matching the emlteut of tim generati(nl field for the links witll the gl(ibal (:ounter; if they nutt(:ll, the content of this tiehl is respect[~d 7. As in [Pereira, 1985]. tile Q D ~dgorithln lla.S tltree types of uodes: 1) :atonfic. 2) :lie(torn 8, and 3) :conqth!x. :atOllli(: tyllc nodes repres(mt at(nni( synll)ol values (such ;~s 'Noun') , :bet tom type n(Jdes are variables and :(:()lttl)lcx tylac nodes ~l.re Ilo(les that have art:s i:ol[litlg (lilt of thenl. Arcs are stored in the m'cqist tiehl. Tile atomic vahl(! is also storc.d in the m'c-list if the node tyttc is :at,imil:. :l lottom nodes succeed in unifyiug with nny uodes and the result of lint(it:alien t~kes tim type ~md the value of the node tlutt the :bottona nI)de w;m unified with. :atonli(: nodes succeed in unifying with :btIttona nodes or :at(lllliC llO(li~s with the mune vallle (Stilted in the arc-list). UnificatioD of an :atomic uode with a :co] t l l ) lex l lOde i l l l l l te ( [ ia tc ly f i l J ls. : co t t l l ) l ex taodes site(reed in unifying with :bottolit nodes or witll :(:OUll)lex trades whose subgrlqdls all unity. ° Figure 2 is the central qllmsi-,lestructlw~ graph unifi(:ation algorithm and Figur('. 3 is the dcrcfel'encing 1° flulction. Figlit'(? 4 shows the a lgor i t l i l l ; fo r (:ollying tti lf l(!s all(1 ~Lrcs (called from lmify0) wllih~ respecting the (:Ollt(mts of ~a~4 "~x~is t~
7~1~ do II(It ]l~tVe ~t separate field for temporary forwtLrding links; instead, we desigllat(t tile integer wdue 9 to repreuent a permanent f,~rwatding llnk. We Ht~trt incrementing the global COUltter f[Olll 10 ,() whel lever the gener;tti(ut lu~trk i8 lIO| 9, the integer vahle 11111~4t e(ltla] the globad COllltter v;tllle to reulmCt the forwaxding link.
8 lqottom i8 called leaf in Pereira'u algorithm. 9Arc wtlues are ,'always It(Idea aLnd never synlbolie V~dlle8 because :atomic *uLd :bottom nodes lilly lie (or ]l(}cO]ll(}) poillted to by luultiph: arl:x (i.e, FS-Sh~ring) depemlil~g on gt0annlar COllHtr.'killtg, and we do not want arcu to (:oltt~tln terlnin~d atomic V~lleO.
l°Derefi~rel|Cillg i8 till opera((loll to recl lrsively traw~rae f . r - w;trding links to return the target mille of forwarding.
AcrEs DE COL ING-92 , NANTgS, 23 -28 AO~" 1992 4 4 1 I'ROC. OF COL ING-92 . NAmES, AUG. 23-28 , 1992
QUASI-DI~qTnuCTIVE ~RAPI[ UNIFICATION ] calling unify0(dgl,dg2): increment *unify-global-counter*: ;; starts front 1(} 11 ret urn (result);
END; copy ~ copy-dg-with-coml)-arcs(dgl); return(copy); dgl.copy ~ nil; :; cutoff ullt:ltrrent copy IF (dg2.copy is non-empty) THEN dg2.copy ~ nil; IF (dgl = dg2)I~THEN return('*T*); ELSE IF (dgl.type = :bottom) THEN forward-dg( dgl,dg2 j t empor asy); return('*T*);
ELSE IF (dg2.type = :bottom) THEN forward-dg( dg2,dgl,:tem porary ); rcturn('*T*);
ELSE IF (dgl.type = :atomic AND dg2.type = :atomic) THEN IF (dgl.arc-list = dg2.arc-list)13THEN forward-dg( dg2,dgl,:tempor ary}: return('*T*);
ELSE throwt4with keyword 'unify-fail; ELSE IF (dgl.type = :atomic OH dg2.type = :atomic) THEN throw with keyword 'unify-fail;
ELSE shared ~ intersectaxcs(dgl,dg2); forward-dg( dg2,dgl,:t empor ary ); 15 FOR EACH arc IN shared DO unifyl(destination of the shared arc for dgl, destination of the shared arc for dE2); new ~ complementarca(dg2,dgl); 16 IFlT(dgl.comp-arc-list is non-empty) THEN
IF (dgl.generation = *unify-gloh;d-counter*) THEN FOR EACH arc IN new DO push as['. to dgl,comp-arc-list,, ELSE dgl.colnp-arc-list ~ nil:
ELSE dgl.genera.tion ~ *unify-glohal-couttter*: dgl.comp-arc-list ~- new; return ('*T*); END:
FigLure 2: The Q-D Un i f i ca t ion Funct ions Tit(' functions Contl)lenlelttarcs((lgl,dg2) and In-
119 indicates a l)ermanent forwarding link. 12 EquM in the 'eq' 8ellse. Bec~tuae of forwarding altd cycles, it is possible that dgl and dg2 are "eq'. 13 Arc-list contains atomic value if the node is of type :atomi(. 14Catch/throw coastxuct; i.e., immediately return to unifydE. lSThis was performed ~dter FOR EACH letup in [Tonrahechi,
19911 which couht haw~ c~.uacd it prtddem writ a sttccessful cyclic call. Thanks are due to Marie Boyle of University of Tuebingen fur suggesting the change.
16Colnplementarcs(dg2jlgl) was called before unifyl recursiena in [Tomabechi, 1991], Currently it is moved to after all unifyl recuraions successfully return. Thanks are ;dso due to Marie Boyle for suggestiug this.
17This check was added after [Tomabechi, 1991] to avoid over-writiltg the conlp-arc-list wll(~ll it is wrltt(,it more than once within one Ulfify0 call. Thanks are duc to Peter Neuhaus of Oniversitiid Karlsruhe for reporting this l)roblem.
C;RAPll NODF" DF',F'F'FERF'NF'ING ]
IF (dg.generation : *unify-global-counter* OR rig.generation = 9) THEN dereferetu:e-dg( for ward-dent );
ELSE dE.forward ~ nil: :; make it GCable retura(dg)',
ELSE return(rig); END;
Figure 3: The Q-D Dere ference Funct ion t('rsc('tarcs(dgl,dg2) return the sct-diff(,renF`(" (the arcs with labels that exist in dg l but not in dg2) and intersection (the arcs with labels that exist both in dg l and dg2). During th(" sct-difl'erence and sctiutersection otlera.tiultS, the (,ulttent of colnp-arc-lists art" respected ms parts of arc lists if the genera.tion mark matchs the current va.lu(, of the globa.l tinting counter. Forward(rig1, dE2, :forward-type) puts (tg2 in tile forwa.rd field of dgl . If the keyword in the fun('tion call is :temporary. the eurrev.t valu(, of the *unify-glob;d-counter* is writtea in the generation fiehl of dgl . If the kcyword is :perman(,nt, 9 is written in the generation fiehl of (lgl. 18 The temporary forwarding links are necessary to handle rcentrancy and cycles. As soon as unification (at any level of r(,cursion through sha.rcd art,s) is performed, a. teml)orary forwarding link is made from dg2 to dgl (dE1 to dE2 if dgl is of type :bottom). Thus, during unification, a. node already unified by othcr recursive calls to unify1 within the same unify0 c',dl has a temporary forwarding link from dg2 to dE1 (ur dg l to dE2). As a result, if this node becomes an int)ut argument node, derefcrencing the node causes dg l a.ud dg2 to lleconte tile Salll(, llo(lc attd unification immediately succeeds.
Thus, a subgraph below an Mrea(ly unified nude will not be checked inore than once even if an a.rgument graph has a. cycle. 19
[ QUASI- DF` STI1UCTIVF, COPYING ] dg.copy.generation 2n ~ *unify-gloh',d-countcr*) THEN ret urn(dg.copy); 21
ELSE IF (dg.type = :atomic) THEN ncwcopy ~ create-node(); 2~ newcopy.type ~ :atolltic; newcopy.arc-list ~ dg,arc-list: Itewcopy.gel|eratiolt ~ *tinily-global-counter*; dg.copy ~ newcopy; ret urn(newcopy);
ELSE IF {dg,type = :bottom) THEN ltewcopy ~ creatc-nodel ); newcopy, type 4~ :hottoltl; I~ewcopy.gem!rlttioll ~ *unify-global-counter*; dg.copy ~ newcopy; ret urtt( newcopy )i
ELSE
18permanent forwardings may be needled by gr~tlltlltar COlllpliers that merge graphs.
l°Also, during copying suhaequent to a mlccessful uniticatioll, two 0d¢:8 COllvergillg into the 8&lltl~ llode will Ilot c~*,lSe ovcrcopying simply because if a node already has a copy then the copy is returned.
AcrF, s DE COLING-92, NANTES, 23-28 AOt3T 1992 4 4 2 PRec. OF COLING-92, NANTES, AUO. 23-28, 1992 lieW(;Opy ~ (:reilt.:-node(); lleWCOpy.type ~ :COlllp|i~x; newcopy.g(~neratioll ~ *ltnify-glolnd-countel*: dg.col)y ~- lieWco|)y: 23 FOR ALL arc IN dg,arc-llst DO n(~warc ~ ctlpy-arc-alid-ct)lnp-llrc(arc)l pllsh ll()w,%rc into newct)py.ttrc-li,t;
I F (dg.coiup-arc-li,t is non-mnpty AND dg.generation - *unify-glohal-counter*) THEN
FOR ALL c(nnp-ar(: IN dg.conll~-itrc-li~t DO li(~wlirc ~-- Col)y-arc-and-colllli-ltrc(colllp-arc}; plish liewltrc into n¢~wcopy.arc-liut; dg,cotnp-arc-list ~ nih return (newcopy):
END;
Figure 4: Node and Arc Copy ing Funct ions
3 Q-D Copying + DS-Sharing In order to a t ta in s t rnc ture -shar ing dur ing QmLsi-
Dest ruct ive gral)h un i t i ca t ion , no n iod i f ieat ion is necessary for the un i f icat ion funct ions descr i t )ed in the prev ious sect ion. Th is sect ion descr ibes the qua.stdes t ruct ive copy ing wi th s t rueturc -shar ing wh ich rep laces the or ig ina l copy ing a lgor i thm. S ince unif icat ion funct ions are unnt0d i t ied , the Q-D uni t iesl ion w i thout s t ru ( : tu re -shar ing eau be mixed t r iv ia l l y w i th the Q-D uni f icat i tm wi th s t rueturc -shar lng if such a mix ture is des i red (by s imply choos ing differeat copy ing f imet ions) . Inf i )r lnal ly, the Q-D copy ing w i th s t ruc ture -shar ing is l )er formed in the fo l lowing way. Atonf ie and ] )ot tom l lodes are shared, A COlllp lex node is shared if l lo nodes be low that node are changed (a node is cons idered ehange(I by be ing a ta rget of fo rward ing or hav ing a val id COlnp-arcl ist) . I f a uode is ehaaged then that in fo rmat ion is 1)~sed Ul) the graph path us ing mult i l ) le-valut~ b ind ing facili ty when a copy of the nodes are recurs ive ly re turned . Two wdues are re turned , the first va lue being the Col)y
(or or ig ina l ) nol le and the second va lue being the f lag represent ing whethe, r any of the node below that node ( inc lud ing t, hat node) h;us been ehanged. A tomic aud bot ton l nodes are a lways sharet l : however , they are cons idered changed if they were a ta rget of forwarding st) that the ' changed ' in fo rn la t ion is passed up. I f the eomI) lex node is a ta rget of fo rward ing , i f no node behiw that node is changed then the ()rigin;d eon lp lex node is shared; however , the ' ( :hanged' inforniat i t )n
20I.e.. the *gtill(Sratioli" fiehl of the iiodt, stored in tile q:olly' field of the "dg' llode. The Mgoritlnn (lescrihed in [Tomabechi, 1991] imt,d ~COlly-ln~rk' fiehl of'dg'. Currently 'generlttion' field replaces tile three lnltrk fiehl described ill the article.
21 I.e.. the cxisthig copy of the ilodc. 22 Creltto8 fin empty node 8tlliCiUr(L ~a'l'lli~ ofl~ratil)li to set it newly i:tl!iited copy node into tim
'copy' field of Mg' w~ dolill Mter reclirSiOll into tubgtaph~ in tile Mgorithnl description in [Toinabechl. 19911 which wa~ it cause of iufinite D2CllrSiOll with it parl icuhtr type of cycle~ lit the graph. By l l loving ill> to ti l ls p(mltion f lol l l after the recilrtdon, 811ch a pr(~l)hmi Call be effectively avoided. Thil l lk8 itr(2 due to Peter Neuhaus for reporting tile pro|lima.
is l>~Lsse(l ut> when the recurs ion re tunts . Be low is the a<:tual a lgor i t lnn descr ip t ion for the Q-D copy ing w i th s t ruc ture -shar ing .
[ Q-I) C . . . . . . . . . . . . . s . . . . . . . ........ S . . . . . . . I
FUNCTION copy-dg-wit h-conq~-arce-share( dg-u nderef I: dg ~ dereference-dg(dg-underef); IF (dg,col)y i8 ito,-enlpty AND dg.ctqiy.generation = *unify-global-counter*) THEN IF (dg = rig.copy) THEN ~a newcopy ~- create-itode( ): newcopy.typc ~- :bottom; tmwcopy.gtmt~r ation ~ *unify-gh)b~d-ctm nt er *; dg.copy ~-- newt:spy; wdues(dg.copy.:changed): 25 ELSE vMue~(dg,col)y,:changed);
ELSE I F (dg ~ dg-underef) THEN copyimde-comp-not - for war ded(dg);
ELSE copy-node-cmnp-fi)rwardedidg); END;
FUNCTION copy~node-comp-not-fi)rwarded(dg): IF (dg,type : :atolnic) THEN values(dg,uil); ;: rt~turn original dg with "liO ch;lllg(~' flag. ELSE I F (dg.type = :bottolll} THEN wdueu(dg.nil): ELSE
I F (dg.cmnp-arc-liat is no.-empty AND rig,generation = *unify-globaLcounter*) THEN lmWCopy ~ creatt:-node(); newcopy.tylm ~ :eonwlex; n(~wcopy.genet&tiolt ~ *ullify-globAl-collnter*: dg.copy ~ newct)py: FOR ALL arc IN dg.arc-list DO newarc first Wdilt~ of copy-arc-and-contp-arc-Mlltre(arc); i)llsh liewitrc into lmwcopy,arc-]ist; FOR ALL conq)-arc IN rig,cutup-arc-list DO ilawltrc ¢~ firl4 t vahlc of copy-~trc-alld-ct )ill p-arc-share( corn [)-arc ): ])uflh ileWltr(: iltto ilew(:opy.arc-|iat; dg.conlp-arc-list ~ nih wdtieu{ llew(:t~py,:chltlt ged ):
ELSE state ~ IdL arcs ~ ldh dg.copy ~ rig 26 , dg.gtmerittiolt ~ *uliify-giol~al-i;o.nt(!r*; FOR ALL art: IN rig.arc-list DO itewar¢,challge~tl ~ (:opy-arC-~lld-t:Olllp-ar(-sh;tr~(arc}; pus|t newart: illt~ arcs: IF (changed has wdue) THEN state , - I:hllligl~d; I F (state has vldue) THEN
IF (rig.copy # dg) THEN dg.copy.arc-liat , Arcs: dg.copy.type ~ :complex; vldues{ tlg.ct~py,:changed );
ELSE liewcopy ~ create-node(); newcopy.type ~- :comtdex; llewcopy.getleratioll ~ *tniify-gl()lnd-ctnlntl~r*; newcopy.arc-liat ~ ~trc~; dg.copy ~-- m~wl:opy; vidues( liewct)py.:t:hallged ) ;
ELSE dg.copy ~ nil; ;;reset copy fiekl values{dg,uil):
END;
FUNCTION copy-node-conq)-forwarded{ dg); IF (dg.type : :g, tomic) THEN values(dg.:changed); ;; return origiaM dg with 'changed' flag. ELSE I F (rig.type ~- :lmttom) THEN values(dg,:changed); ELSE
IF (dg,comp-arc-li~t is uon-enipty AND dg,generMion : *unify-globM-counter*) THEN newcopy , - create-node(): newcopy.tylm *- :coilifdex;
ACRES DE COLING-92, NAMES, 23-28 AO~I 1992 4 4 3 PROC. OF COLING-92, NANTES, AUG. 23-28, 1992 newcopy.gencratio~l ~ *utdfy-global-counter*; slle(:essful tllliticatiOllS to the total ltUlllbcr of Itllificadg.copy ~ newcopy: tions. Wc parsed cach selltcncc three times on a Sym- FOR ALL arc IN dg.arc-list DO I)oli(:s 3620 using three tin}float}on ntethods, namely,
Ilew&rc (- first value of capy-arc-and-coml)-arc-sharc(arc); Wroblewski's algorithln, a qua,si-dcstrttctive lllethod pllslt new&re }taro newcopy.arcdist: FOR ALL c<>ml)-arc IN dg.comp-arc-list DO ilewar(: first value of copy-arc-and-(:Olllp-ar(:-sh are( colll ])-arc/; pudt newarc into l|eWcg)y.arc-list; dg.comp-arc-list ~ nil: vMm~s(newcopy,:dlanged );
ELSE stale + nil, arcs ~ tail; without structure-sharing, and a qu,%i-destructive method with structure-shariug. Wc took tile shortest elapsed time for ea(:h metho<l ( 'W' represents Wroblewski's algorithnl with a modification to handle cycles and wtrialllcs 29, 'QD' represents the <luimidestructive nletlmd without structure-sharing, slid 'QS' represents the prol)osed lnethod with structuresharing). Data stru(:tures arc the same for all three dg.col)y ~ (Ig, dg.gcneration + *Ulfify-glol>al-counter*; unification methods ex(:el)t for additional fields for FOR ALL art: IN dg.arc-list DO imwarc,changed +: COl)y-arc-an( -comp-arc:s lare(arc); )l II -ar -list ill tile Q-D lnethod8. 8anle fltllctil)ltS push newarc into arcs; are llsed to interface with Eal'ley~s parser and tile IF (dmnged has value) THEN stat~ ~ cbal|ged; IF (state }tits value) THEN
IF (rig.copy =fi dg) T I tEN rig.copy.arc-list ~ arcs: dg.copy.type ~ :comt)lex; value,(dg.col~y.:changed);
ELSE newcopy ~ create-node(); newcopy.type ~-- :complex;
SalIIC sul)fllllCtiOllS are used wherever possible (snch ;as creation sl id access of arcs) l, ll lnilthllize th(! diffcrem:eu that are not purely algorlthltfi<:. 'Nmnber of Copies' represents the numl)er of nodes created durillg each parse. 'Nlll l lber of Arcs' rcprcsents the nlllllber of arcs created durillg each parse.
We used Earley's parsing 'algorithnl for the experintent. The Japanese gralmnm' is based on t lPSG newcopy.gencration ~ *unify-gbJb~d-(:ounter*; newcopy.arc-list ~ a~cs; dg.copy ~ neweopy; v~dueA( newcopy.:cllangcd);
ELSE dg,copy ~ nil; vahte~(dg,clmnged); ;; considered changed
END;
Col)y-rig-wit h-coml)-~rcs-dtare(in put -,xr(:.value ); IF (changed has value I TItEN lal)d + inpubarc.label; value ~ destination; values(a new arc witb lalml and value,:cluulged);
ELSE rabies(input-arc jail): ;; return original arc END;
F igure 5: Structure-Sharing Copy ing Funct ions
4 Experiments Table 1 shows the resltlts of our experiments using all HPSG-11,~sed sample Japanese granmtar dcvdoped at ATR br a conference registration telephone dialogue domain. 'Unifs' represents the total ltulnl/er of top-level unifications during a parse (i.c, the munl)er of calls to the top-loyal "unify-dg', and not 'tinily1') 28. 'USratc' represents the ratio of
24 Currently, all lIOdetl arc Col)ted ill a cych~ il~ order to prevent the split of the copy ~uld the original when node above all uladl~.ngcd original i8 modified. Tbanks are due to Makoto 'I'ak~d,a~i of TIS for suggesting the fix. Of c,urue, a better method, if possihle, would be 1o copy tim whole cycle only wheat at least one node in the cycle i~ modified,
25'Values' retltrn nlllltil)le values ~rOlll ~t fllnCtioII. In our algoritlmt, two values are retunlcd. The first value is the result of copying, and the second value is ~t flag iMicatiag if tlmre wa~ any modificatiolt to the node or to ally of its desc(!n(lallt8.
26Temporarily set copy of the dg 1o be itself, 27Multil)te-value-hind call. The first value is homld to
'newarc'. arid the second vahte is bt)und to 'dumged'. 28Unifyl in called several times the number (>f uttify-dg in the gtalnl|l&r ilSC(I ill the eXl)erilllCltt. For exanlpb! nnifyl wi~ analysis ([Ponard and Sag, 1987]) eovering llhenomena such as coordination, case adjmlction, adjunets, control, shLsh categories, zero-pronouns, in terrogativcs, WH constructs, and sonic pragmatics (speaker, hearer relations, politeness, etc.) ([Yoshimoto and Kogm'e, 1989]}. The grammar covers many of the imllortant linguistic phenomena in conversational Japaucse. The grammar graphs which are convertcd front the l)atll equations contaiu 2324 no(tcs, a° Wc used 16 Sclttenecs from a sanlplc telet/hone convcrs~tion dialog whi(:h range from very short sentenets (one word, i.e., tie 'no') to rdat ivdy hntg ones (such as soredehakochirakarasochiranitourokuyoush, iwoookuriitashimasu 'In that case, wc [speaker] will send you [hearer] the registration form.'). Thus, tltc number of (toll-level) unifications per senteltce wu'icd widdy (from 6 to over 500).
5 Discussion: Pereira ([Percira, 1985]) attail ls structure-sharing I)y having the rcsult graph share information with the origiw, d gr~tphs by storing charges to tile 'enviroltmerit'. There will be tlle log(d) overhead (where d is the nuM)er of nodes ill a graph) associated with Percira's ntetho<l that is rcqttircd during node access to ,~ssenfl>le the whole graph from the 'skeleton' and the updates ill thc 'environment'. Ill the proposed sdtcmc, since tim arcs dircetly lloint to the original graph structures there will be no overhead till" node accesses. Also, during unificatioli, siltce citaltges art!
called 3299 times for sentence 9 when Itnify-dg was called 480 tillies.
29 Kogure ([Kogur< 1989]) des(:ribe~ It trivial time modification to WrohlewRki's algorithm lo handle cycles which is used ill oltr experillleltts,
3tlDisjunctive equation~ are l)reproceH~ed hy the grammar reader module to expand into cross-multiples, whereas il~ ATR% SL-TraNs syRtem. Kasl)er's method ([Kauper. 1987]) to handle disjunctive feature-strltctures ia adopted.
ACRES DE COLING-92, NANTES, 2348 AOt~T 1992 4 4 4 PROe. OF COLING-92, NANTES, AUG. 23-28, 1992 sent# Unifs USrate
1 6 0 .50 2 101 0 .34
3 18 0 .22 4 71 0 .55 5 305 0 ,37 6 59 0.27 7 6 0,50 8 81 0.51 9 480 0 .37 10 555 0.41 i i 109 0.45 12 428 0 .33 13 559 0.39 14 52 0.38 15 77 0 .55 16 77 0.55 to ta l 2984 (Z for total)
Elapsod timo(nec) Num of Copies W QD QS w QD q3 o ,2o o .15 0 .13 107 79 18
2,53 1 .16 1 .10 2285 1317 407
0 .40 0 .20 0 ,20 220 111 26
2 .20 1.24 0.91 2151 1564 514 13.78 6 ,51 3 .65 9092 5224 1220
3,20 0 .64 0 .50 997 549 97 0.21 0 .13 0 .11 107 79 18 3 .17 1 .59 1 .21 2406 1699 401
24 .62 8 .11 5 .74 15756 8986 1696 40 .15 16 .39 8 .80 18822 11234 2737
4.60 1 .71 1 .41 2913 1938 555 19.57 8 .24 4 .45 13363 7491 1586 37 .76 11 .74 6 .23 17741 9417 2483
3 .61 0.90 0.50 947 693 107 2 .50 1.57 0.93 2137 1513 428 2 .53 1 .57 0 .90 2137 1513 428
161.23 61.85 36 .77 91181 53407 12721 ioo~ 38.4~ 22 .8~ 100~ 58 ,6~ 14~
~Sd)le 1: Compar i son of three methods stored directly in the nodes (in the tluasi-destructivc maturer) thcrc will be no ovcrhead for rctlccting the changes to gral)hs during unitic;ttion. We share the l)rittciph~ of storing changes in a rcsU)rablc way with [Karttuncn, 1986]'s rcvtwsilfle unification and copy graphs only after a socccsshtl unification. However, Kal'ttllllCll~S nlcthod (lots llOt list! strllctllrc-sharilig. Also, }11 Kal'ttullcn's llltttll()t[ 31, whenever it destructive chaage is about to bc made, tile attribute vahle pairs a2 stored in the body of the tlodc arc saved illto all array. The dag node structure itself is idso saved in another arrlty. These wtlucs arc restored after the top lcvcI unification is c(mq)leted. {A t:opy is madc prior to the rcstoratiou Ol)cration if the unification wlus +t successful one.) '['has, ill Karttuncn's lncthod, clmh node ixI the entire argulllcnt gral)h that hius been destructively modified must t)c restored SCl>aratcly by l'eXricviltg the attributc-values savcd ill an array and rcsctting th,! values into the (lag structure skeletons sltvcd in another array. Ill the Q-D method. Olt(! illCl'ell/ellt to the global COlllltcr c.q.ll iav+didatc all tht'. changes made to tilt! no<tern [Karttunen slid Kay, 1985] suggests the use of lazy evaluation to delay dcstructive chalLges during unificatiou. [Goddcn, 1990} presents one method to delay copying until a destructive change is al)out to take phtcc. Godden uses delayed closures to directly imphm|cnt lazy evaluatitm during unification. While it may be concel)tually straightforward to takc iulvantagc of delayc(I cVahlation functionalities ill progranuning laagtlages, actllal efficiency gain fl'on! such a schelnc may not bc significant. This is l)et:aase such a schenle siml)ly shifts t4e time and space consmned for Col)ying to creating and evaluating closures (which couhl be very costly compared to 'dcfstruct" operations to create COl)ics
31The discussion of Karltunen's lnethod is ba.e,l on the D PATR imphnuent;ttion on Xerox 1109 machines ([Karttunmt, 1986]).
32I+e., arc stru(:turen: 'label" and 'vld[l(~' ])ilii'~ ill oUr w~cabulary.
Num of Arcs
2441 1917 760
182 183 62
2572 2334 710 17358 12427 3394 20323 15375 5116
3089 2712 992 14321 10218 3059 19014 13055 4471
893 983 199 2436 2185 793 2436 2185 793
97946 73950 23776 100~ 76% 24~ which arc often effectively ()l)timized lit many tom ...... • cial ....... lfilcrs). [Kog,|l'C, 1990] anti [Eulelc. 19611 also use the lazy evaluation i(h',a to delay destructive changes. Both Kogurc all(l Eme, h~ avoid direct usage of delayed evMuation by using pointer Oln:rations. As b3mchr suggests, KogurCs method also requires a special dcl)endcncy inf(,rmation to bc mifintained which adds all overhead ahmg with the cost fin' traversing tile dCl)cudency arcs. Also, a secon(I travcrsa] of the set of dellelldellt liodes i8 required for actually pcrfl)rming the copying. Emele proposes a method of dcrcfercncing by adding enviromnent inforlltatioli tllld, carries it scqtl(Hl(:t! of gCllCl'atioll COllll* tcrs so that a specific generation node (:all I)(~ fOlllld by traversing tim forwarding links until a node with that generation is found. While this allows undoing destructive changes cheaply by backtracking the envirolllOCllt, every tinlc a spccilic graph is to bc at:- (:cssed the whoh! gt'aph ilcctls tO bc rccollstrll(:ted by following the fol'wardillg pointers ,~cqucntildly as speciticd in the environment list (cxt:et)~ for the root node) to find the node that shal'CS the smne generation number as the root llOde. Therefore, similar to Pcrcira's mcthotl, there will be Nlog(d) ovcrhcad iLssociated with constructing t!ach graph every tinle & gral)h is accessed, where (1 is the llUillbCr of nodes ill the graph and N is the average depth of the tmvironlllClttal dcfcrcncc chain, This would cause a probh!nl if the algtlrithm is adolltcd fin' a large-sclde systcm ill which result graphs arc unified agidnst other graphs many times. Like Wroblewski's method, "all three lazy methods (i.c, Godden's, Kogure's and Emele's) suffer fi'mn the t)roblenl of Early Copying ms defined in [Tonlabcchi, 1991]. This is because the copies that arc incrcnmntally created u 1, to tile point of failure during the same topAcvel unification arc wasted. The problent is inherent ill increlnental copying scheme and this probhml is elinfil|ated completely in [Karttuncn,
ACRES DE COL1NG-92, NANTES, 23-28 Aotrr 1992 4 4 5 PROC. oF COLING-92, NANTES, AUO. 23-28, 1992
19861 and ill tile Q-D nmtltod. 3a There is one l/otential problent with the structure,- sharing idea whMt is shared by each of the schemes inchlding tile proposed tnethod. This ltallpens when operations other tllan ttnification modify the graphs. (This is typical whco a parser cuts off" a part of a graph for sltbsequellt analysisa4.) When such ol)- erations are perfornmd, structure-sharing of t)ottolll (vlu'iablc) nodes stay cause probhmts when a subgraph cotttaitdog a 1)ottmn is shared by two different graphs and these graphs are used as argtl l l le l l tS of a utfification function (either ~Ls the part of the same input graph or as ehmumts of dg l and dg2). When a gt'aplL that shares st bottl)lO ( lode iN llOt Ilsed ill its entirety, then the, represented i: lmstraint postulated by the path leading to the bottotn no(h; is no longer the same, Therefl>re, when such a graph appears in the same unification aloog with soIoe other graph with which it DS shares the same bottotn node. there will 1)e a false FS-Sharing. (If the graph is used in its entirety this is not a problem since the two graph paths would unify anyway.) Th is problenl happens mdy when neither of the two graphs that DS-Sltares the same I)ottol l l node wan ultified against SOille other graph before al)pearing in the santo unification, as {If either was once unified, h)rwardiug wouht have avoided this prol)lent). The methods to avoid such a problent can be 1) As long as these convergence of bottoln nodes are used h)r features that are not pressed up during i)arsing, the ln'oblems does not affect the result of parse in any way whMt scents the ca,se with the gr~mtmars at ATII azl(l CMU. 2) A parser call tie modified so that when it modifies a graph other than through graph unification a6, it et'eatcs copies of the arc stru(:tures containing the bottotn nodes. In the prolmsed tnethod this can be done by calling the copy function without structure-sharing llefl)re a parser ntodifics a grallh. 3) A parser can lie rood(tied so that it does not (:lit off parts of graphs and use the graphs in their entirety (this should not add emnplexity (mcc strttctttre-sharing is introduced to unification). Thus, althtmgh the space and t ime reductioo attained by structure-sharing (Jail t)e significant. DS-Shariag can cause l)roblems unless it is ttsed with a eautiott (by making sure variM)le sharing aaLazy methods delay eopyiug until a destructive chaalge is to be perforlne.d Do that unnecessary copies are not created within a lmrticular recurs(on into a unification function; howover, 8il|ce each shared arc recllrsion is indellendent (llOlldeterlllillistic). (!villi if there are 11o unltecesa&ry copies created at ,dl iu otte particular relalrsioll, if there is a failure in 8Ollllr other shared art: recurs(on (at some depth), then the copied that are created hy successful shared arc recurs(ass up to the point of detection of failure will beconm wasted, As long as the haste contr<fl structure retnltins incremental, this is inher- (!lit ia the increlllental |uethod. In otheI wolds, the problem is inhereut in these ilmremental methods by definition.
34 For example, lnltny parse[.~ cut off a subgraph of the path 0 hJr applying further rules whmz it rule is accepted.
35Such cases lltay happen whell the 8allle rule (such as V V} augluented with a heavy use of convergence ill the bottonl nodes is applied malty times during a parse.
36Stlch as when a rule is accepted and suhgraph of O path is Cltt off.
does not cause crroncous sharing by using these or some othm" methods).
6 Conclusion The structure-sharing scltemc introduced ill this paper made the Q-D Mg(~ritlnn run significantly f~mter. The original gain of the Q-D algorit, hnt was due to the fact that it does not create ally Over Copies or Early Col>ies whereas iIIcrelllelltal (:opyillg sfllI~Ille inherently produces Early Copies (iLs defined in [Totnal)echi, 19911) when a unification fails. Tilt: prol)osed schenm lllakes the Q-D algotfflmi fully i~vl)i(1 lh~dundaltt Collies as well by only copying the lowest nodes that need to be eoI)ied due to destrtt(:tive chatlges caused by successful unifications only. Since there will bc virtually uo overhead associated with structure=sharlng (except far returning two vahl(!s illstead (If oDc' to pa.ss tip :chattge(l illforltlatioll wht!ll rt!- curs(oil for copying rcturos), the perfornlatlee of the prol)osed strnl:ture-sharing schel l le should llOt drop eveii when the granmlar size is significantly scaled Ul). With the denttmstratcd speed of the algorithm. as well as the ability to handle cyclicity in the graphs. mid ease of switching betwemt strueture-sharittg attd non-structure sharing, the algorithm couhl lie a viable alternative to exist ing tttfifit:ation algorithnts used in current nature| language systems.
