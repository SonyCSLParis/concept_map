1 Introduction As it has become easy to get structured corpora such as annotated texts, many researchers have applied statistical and machine learning techniques to NLP tasks, thus the accuracies of basic NLP tools, such as POS taggers, NP chunkers, named entities taggers and dependency analyzers, have been improved to the point that they can realize practical applications in NLP.
The motivation of this paper is to identify and use richer information within texts that will improve the performance of NLP applications; this is in contrast to using feature vectors constructed by a bagof-words (Salton et al., 1975).
We now are focusing on the methods that use numerical feature vectors to represent the features of natural language data. In this case, since the original natural language data is symbolic, researchers convert the symbolic data into numeric data. This process, feature extraction, is ad-hoc in nature and differs with each NLP task; there has been no neat formulation for generating feature vectors from the semantic and grammatical structures inside texts.
Kernel methods (Vapnik, 1995; Cristianini and Shawe-Taylor, 2000) suitable for NLP have recently been devised. Convolution Kernels (Haussler, 1999) demonstrate how to build kernels over discrete structures such as strings, trees, and graphs. One of the most remarkable properties of this kernel methodology is that it retains the original representation of objects and algorithms manipulate the objects simply by computing kernel functions from the inner products between pairs of objects. This means that we do not have to map texts to the feature vectors by explicitly representing them, as long as an efficient calculation for the inner products between a pair of texts is defined. The kernel method is widely adopted in Machine Learning methods, such as the Support Vector Machine (SVM) (Vapnik, 1995). In addition, kernel function ������� �� has been described as a similarity function that satisfies certain properties (Cristianini and Shawe- Taylor, 2000). The similarity measure between texts is one of the most important factors for some tasks in the application areas of NLP such as Machine Translation, Text Categorization, Information Retrieval, and Question Answering.
This paper proposes the Hierarchical Directed Acyclic Graph (HDAG) Kernel. It can handle several of the structures found within texts and can calculate the similarity with regard to these structures at practical cost and time. The HDAG Kernel can be widely applied to learning, clustering and similarity measures in NLP tasks.
The following sections define the HDAG Kernel and introduce an algorithm that implements it. The results of applying the HDAG Kernel to the tasks of question classification and sentence alignment are then discussed.
2 Convolution Kernels
Convolution Kernels were proposed as a concept of kernels for a discrete structure. This framework defines a kernel function between input objects by applying convolution “sub-kernels” that are the kernels for the decompositions (parts) of the objects.
�
�����������
� are
�'&
(�(�(
&
�
�)&
� such that %*�+ﬁ,� ��� is true if ﬁ are the “parts” of � . %.- � �/��� is defined as %0- � �/�,�1ﬂ32�ﬁ54 %6�7ﬁ,� ����89�
Suppose ��� :�;� , ﬁ be the parts of � with ﬁ<ﬂ �
�
������� � �
�
����������
� . Then, the similarity �@�/��� �� between � and is defined as the following generalized convolution:
A$BDCFEHGJILK
\
I7c (1)
We note that Convolution Kernels are abstract concepts, and that instances of them are determined by the definition of sub-kernel �# 9�/�d 9� J Y� . The Tree Kernel (Collins and Duffy, 2001) and String Subsequence Kernel (SSK) (Lodhi et al., 2002), developed in the NLP field, are examples of Convolution Kernels instances.
An explicit definition of both the Tree Kernel and SSK �@�/��� �� is written as:
A$BDCFEeG9IfK�gihjBDCFIlkmh9BDGJI7noK;p
BDG9I7c (2)
Conceptually, we enumerate all sub-structures occurring in � and , where s represents the total number of possible sub-structures in the objects. t , the feature mapping from the sample space to the feature space, is given by td�����>ﬂ � t � �/��������������tduv����� ���
In the case of the Tree Kernel, � and be trees. The Tree Kernel computes the number of common subtrees in two trees � and . tdw_����� is defined as the number of occurrences of the x ’th enumerated subtree in tree � .
In the case of SSK, input objects � and are string sequences, and the kernel function computes the sum of the occurrences of x ’th common subsequence t w �/��� weighted according to the length of the subsequence. These two kernels make polynomialtime calculations, based on efficient recursive calculation, possible, see equation (1). Our proposed method uses the framework of Convolution Kernels.
3 HDAG Kernel
3.1 Definition of HDAG This paper defines HDAG as a Directed Acyclic Graph (DAG) with hierarchical structures. That is, certain nodes contain DAGs within themselves.
In basic NLP tasks, chunking and parsing are used to analyze the text semantically or grammatically. There are several levels of chunks, such as phrases, named entities and sentences, and these are bound by relation structures, such as dependency structure, anaphora, and coreference. HDAG is designed to enable the representation of all of these structures inside texts, hierarchical structures for chunks and DAG structures for the relations of chunks. We believe this richer representation is extremely useful to improve the performance of similarity measure between texts, moreover, learning and clustering tasks in the application areas of NLP.
Figure 1 shows an example of the text structures that can be handled by HDAG. Figure 2 contains simple examples of HDAG that elucidate the calculation of similarity.
As shown in Figures 1 and 2, the nodes are allowed to have more than zero attributes, because nodes in texts usually have several kinds of attributes. For example, attributes include words, partof-speech tags, semantic information such as Wordis of dependency structure sentence coreference
He is one of the most famous
Junichi Tsujii is the Gereral Chair of ACL2003. He is one of the most famous researchers in the NLP field.
:node
NPNP
NP
ORG
Figure 1: Example of the text structures handled by HDAG p1 p2 p5p4p3 G1 p6 p7
Net, and class of the named entity.
3.2 Definition of HDAG Kernel First of all, we define the set of nodes in HDAGs y
� and y{z as | and } , respectively, ~ and  represent nodes in the graph that are defined as 2~, ~ w
�
|� xﬂ
J��������� | 8 and 2J YŁ�}� #ﬂ3����� �a } 8 , respectively. We use the expression ~ �6 ~J  ~f to represent the path from ~� to ~  through ~  .
We define “attribute sequence” as a sequence of attributes extracted from nodes included in a subpath. The attribute sequence is expressed as ‘A-B’ or ‘A-(C-B)’ where ( ) represents a chunk. As a basic example of the extraction of attribute sequences from a sub-path,  z

� in Figure 2 contains the four attribute sequences ‘e-b’, ‘e-V’, ‘N-b’ and ‘N- V’, which are the combinations of all attributes in  z and   . Section 3.3 explains in detail the method of extracting attribute sequences from sub-paths.
Next, we define “terminated nodes” as those that do not contain any graph, such as ~ z
, ~l ; “nonterminated nodes” are those that do, such as  � , � .
Since HDAGs treat not only exact matching of sub-structures but also approximate matching, we allow node skips according to decay factor !�  $J� when extracting attribute sequences from the sub-paths. This framework makes similarity evaluation robust; the similar sub-structures can be evaluated in the value of similarity, in contrast to exact matching that never evaluate the similar substructure. Next, we define parameter  ( ﬂ J��J������ ) as the number of attributes combined in the attribute sequence. When calculating similarity, we consider only combination lengths of up to  .
Given the above discussion, the feature vector of HDAG is written as td� y
��� , where t represents the explicit feature mapping of HDAG and s represents the number of all possible  attribute combinations. The value of t w y
� is the number of occurrences of the x ’th attribute sequence in HDAG y
; each attribute sequence is weighted according to the node skip. The similarity between HDAGs, which is the definition of the HDAG Kernel, follows equation (2) where input objects � and are y
� and y{z
, respectively. According to this approach, the HDAG Kernel calculates the inner product of the common attribute sequences weighted according to their node skips and the occurrence between the two HDAGs, y
.
We note that, in general, if the dimension of the feature space becomes very high or approaches infinity, it becomes computationally infeasible to generate feature vector td� y
� explicitly. To improve the reader’s understanding of what the HDAG Kernel calculates, before we introduce our efficient calculation method, the next section details the attribute sequences that become elements of the feature vector if the calculation is explicit.
3.3 Attribute Sequences: The Elements of the Feature Vector
We describe the details of the attribute sequences that are elements of the feature vector of the HDAG Kernel using y in Figure 2.
The framework of node skip We denote the explicit representation of a node skip by ”  ”. The attribute sequences in the sub-path under the “node skip” are written as ‘a-  -c’. It costs  to skip a terminated node. The cost of skipping a
`
¤ -b ¨¥ ¡
K
« §
«O­°©®« ¬ (c-d)-c 1 non-terminated node is the same as skipping all the graphs inside the non-terminated node. We introduce decay functions ±Ł²��~f� , ³°²o�/~f� and ´'²�/~f� ; all are based on decay factor  . ±.²a��~f� represents the cost of node skip ~ . For example, ± ² �/~d��ﬂµJ z
 ¶ z
. ³�²�/~f� represents the sum of the multiplied cost of the node skips of all of the nodes that have a path to ~ , ³�²o�/~j�1ﬂ
9 that is the sum cost of both ~ z and ~ that have a path to ~ , ³�²o�/~ � �"ﬂ·9��o¸Y� . ´
²
�/~f� represents the sum of the multiplied cost of the node skips of all the nodes that ~ has a path to. ´¹²!�/~ z z has a path to ~F .
Attribute sequences for non-terminated nodes We define the attributes of the non-terminated
� and   .
Details of the elements in the feature vector The elements of the feature vector are not considered in any of the node skips. This means that ‘A-  -B-C’ is the same element as ‘A-B-C’, and ‘A-  -  - B-C’ and ‘A-  -B-  -C’ are also the same element as ‘A-B-C’. Considering the hierarchical structure, it is natural to assume that ‘(N-  )-(d)-a’ and ‘(N-  )-((  - d)-a)’ are different elements. However, in the framework of the node skip and the attributes of the nonterminated node, ‘(N-  )-(  )-a’ and ‘(N-  )-((  -  )-a)’ are treated as the same element. This framework
Table 2: Similarity values of y
� and y z in Figure 2 »
K¢
¡
¦
¥
§
¡
¥
£ achieves approximate matching of the structure automatically, The HDAG Kernel judges all pairs of attributes in each attribute sequence that are inside or outside the same chunk. If all pairs of attributes in the attribute sequences are in the same condition, inside or outside the chunk, then the attribute sequences judge as the same element.
Table 2 shows the similarity, the values of �"¼
�½!¾ y z
� , when the feature vectors are explicitly represented. We only show the common elements of each feature vector that appear in both y y
� or y{z becomes very large.
¶ z z twice. That is why the similarity value in Table 2 does not contain ‘c-  ’ in ~� and ‘(c-  )-  ’ in   , see Table 1.
3.4 Calculation First, we determine ¿FÀ6� ¶ ��ÁO� , which returns the sum of the common attribute sequences of the Â - combination of attributes between nodes ~ and  .
ÃRÄÅB7Æ�EbÇ�ILK
Ä
B
Î E if Ï ¡ B   IfKÑÐ and Ï ¡ B « IfKÑÐ
Ò7N qÔÓ
«
Ú
N qHÓ
TVÕ7W
Ò7N qÔÓ otherwise (4)
Þdßaà
�/~f��j� returns the number of common attributes of nodes ~ and  , not including the attributes of nodes inside ~ and  . We define function x+Å��~f� as returning a set of nodes inside a non-terminated node ~ . x+Å��~f�áﬂµâ means node ~ is a terminated node. For example, x+Å��~!�m�ﬂ2~ z
�,ﬂâ .
We define functions ã{À.��~f��9� , ã¹ä À
�/~f��j� and ã
Ý¹Ä�B
È È
E if ímî Ì7B   ILKÑÐ9c (10)
Function ïFð à ��~f� returns the set of nodes that have direct links to node ~ . ïFð à �/~f�1ﬂñâ means no nodes have direct links to ¶ . ïFð à �/~!j�òﬂ 2~ z
��~ª�m�,ﬂâ .
Next, we define �@��~f��9� as representing the sum of the common attribute sequences that are the Â - combinations of attributes extracted from the subpaths whose sinks are ~ and  , respectively.
A.Ä,B
À
��~f��9� , needed for the recursive calculation of � À ��~f��9� , are written in the same form as ã'À"�/~f��j� , ã ä
À
À
�/~f��j� respectively, except for the boundary condition of ô À �/~f��j� , which is written as:
ó
Finally, an efficient similarity calculation formula is written as
AŁõ
\öl÷
B
I7c (13)
According to equation (13), given the recursive definition of �$À.�/~f��j� , the similarity between two HDAGs can be calculated in ú�/* |e } � time1.
3.5 Efficient Calculation Method We will now elucidate an efficient processing algorithm. First, as a pre-process, the nodes are sorted under the following condition: all nodes that have a path to the focused node and are in the graph inside the focused node should be set before the focused node. We can get at least one set of ordered nodes since we are treating an HDAG. In the case of y
� , we can get ûÔ~ z
, ~J , ~J , ~ � , ~  , ~lü , ~!ý . We can rewrite the recursive calculation formula in “for loops”, if we follow the sorted order. Figure 3 shows the algorithm of the HDAG kernel. Dynamic programming technique is used to compute the HDAG Kernel very efficiently because when following the sorted order, the values that are needed to calculate the focused pair of nodes are already calculated in the previous calculation. We can calculate the table by following the order of the nodes from left to right and top to bottom.
We normalize the computed kernels before their use within the algorithms. The normalization corresponds to the standard unit norm normalization of
1We can easily rewrite the equation to calculate all combinations of attributes, but the order of calculation time becomes þ
Biß �'ßVß��Åß[I for ����� �� ��� �� ���� �� ++� ﬀ
Sﬂﬁ ﬃ �ﬂ!#"%$'& ��( S � ﬃ)�*!+"ﬂ$ �,��-/./0�� ﬃ �1!+"ﬂ$ � if �+23� ﬃ � �54�76 and �+2�� " $8�94�76 foreach :�;<�+23� ﬃ � � foreach =>;?�+2�� " $8� for ��@ � �� �@A B23 C@ ++ � (,D�� ﬃ � !#" $'� += E�F)��:G�HE�FI��=+�HJK��: ! =+� end end end else if ��2�� ﬃ ���94�76 foreach :�;<�+23� ﬃ�� � ( S � ﬃ �G!C"ﬂ$ � +=E F ��:*�HL F ��:G�H-M./0���: !+"�$ � end else if ��2�� "�$ �54�76 foreach =>;?�+23� "ON � (JSﬂ� ﬃ � !C" $8� += E�FP��=+�HL�F/��=+�H-M./0�� ﬃ � ! =+� end end foreach :�;?Q�R108� ﬃ �+� for ��@ �S�% �@T B2� �@ ++ � UWV V
D
D for ��@ �S�% �@T B2� �@ ++ � UWV
D
D
D
V g
Figure 3: Algorithm of the HDAG Kernel examples in the feature space corresponding to the kernel space (Lodhi et al., 2002).
n
AáBDCFEbGJIFK
A$BDCFEeG9I
4 Experiments
We evaluated the performance of the proposed method in an actual application of NLP; the data set is written in Japanese.
We compared HDAG and DAG (the latter had no hierarchy structure) to the String Subsequence Kernel (SSK) for word sequence, Dependency Structure p1 p2 p5p4 p3 p6 p7
George Bush purchased a small interest in which baseball team ? NNP NNP VBD DT JJ NN IN WDT NN  NN .
PERSON NP
NP NPPP
Question:  George Bush purchased a small interest in which baseball team ?
p8 p9 p11 p10 p12 p13 p14 p1 p5p4 p6 p7 George Bush purchased a small interest in which baseball team ?
VBD DT JJ NN IN WDT NN  NN .PERSON p8 p9 p10
(c) Word Order p1 p5p4 p6 p7
George Bush purchased a small interest in which baseball team ? VBD DT JJ NN IN WDT NN  NN .PERSON p8 p9 p10p2 p3
Figure 4: Examples of Input Object Structure: (a) HDAG, (b) DAG and DSK’, (c) SSK’
Kernel (DSK) (Collins and Duffy, 2001) (a special case of the Tree Kernel), and Cosine measure for feature vectors consisting of the occurrence of attributes (BOA), and the same as BOA, but only the attributes of noun and unknown word (BOA’)were used.
We expanded SSK and DSK to improve the total performance of the experiments. We denote them as SSK’ and DSK’ respectively. The original SSK treats only exact  string combinations based on parameter  . We consider string combinations of up to  for SSK’. The original DSK was specifically constructed for parse tree use. We expanded it to be able to treat the  combinations of nodes and the free order of child node matching.
Figure 4 shows some input objects for each evaluated kernel, (a) for HDAG, (b) for DAG and DSK’, and (c) for SSK’. Note, though DAG and DSK’ treat the same input objects, their kernel calculation methods differ as do the return values.
We used the words and semantic information of “Goi-taikei” (Ikehara et al., 1997), which is similar to WordNet in English, as the attributes of the node. The chunks and their relations in the texts were analyzed by cabocha (Kudo and Matsumoto, 2002), and named entities were analyzed by the method of (Isozaki and Kazawa, 2002).
We tested each  -combination case with changing parameter  from 0.1 through 0.9 in the step of 0.1. Only the best performance achieved under parameter  is shown in each case.
Table 3: Results of the performance as a similarity measure for question classification
¡ 1 2 3 4 5 6 HDAG - .580 .583 .580 .579 .573 DAG - .577 .578 .573 .573 .563 DSK’ - .547 .469 .441 .436 .436 SSK’ - .568 .572 .570 .562 .548 BOA .556 BOA’ .555
4.1 Performance as a Similarity Measure
Question Classification We used the 1011 questions of NTCIR-QAC1 2 and the 2000 questions of CRL-QA data 3 We assigned them into 148 question types based on the CRL-QA data.
We evaluated classification performance in the following step. First, we extracted one question from the data. Second, we calculated the similarity between the extracted question and all the other questions. Third, we ranked the questions in order of descending similarity. Finally, we evaluated performance as a similarity measure by Mean Reciprocal Rank (MRR) (Voorhees and Tice, 1999) based on the question type of the ranked questions.
Table 3 shows the results of this experiment.
Sentence Alignment The data set (Hirao et al., 2003) taken from the
“Mainichi Shinbun”, was formed into abstract sentences and manually aligned to sentences in the “Yomiuri Shinbun” according to the meaning of sentence (did they say the same thing).
This experiment was prosecuted as follows. First, we extracted one abstract sentence from the “Mainichi Shinbun” data-set. Second, we calculated the similarity between the extracted sentence and the sentences in the “Yomiuri Shinbun” data-set. Third, we ranked the sentences in the “Yomiuri Shinbun” in descending order based on the calculated similarity values. Finally, we evaluated performance as a similarity measure using the MRR measure.
Table 4 shows the results of this experiment.
2http://www.nlp.cs.ritsumei.ac.jp/qac/ 3http://www.cs.nyu.edu/˜sekine/PROJECT/CRLQA/
Table 4: Results of the performance as a similarity measure for sentence alignment
¡ 1 2 3 4 5 6 HDAG - .523 .484 .467 .442 .423 DAG - .503 .478 .461 .439 .420 DSK’ - .174 .083 .035 .020 .021 SSK’ - .479 .444 .422 .412 .398 BOA .394 BOA’ .451
Table 5: Results of question classification by SVM with comparison kernel functions
¡ 1 2 3 4 5 6 HDAG - .862 .865 .866 .864 .865 DAG - .862 .862 .847 .818 .751 DSK’ - .731 .595 .473 .412 .390 SSK’ - .850 .847 .825 .777 .725
BOA+poly .810 .823 .800 .753 .692 .625 BOA’+poly .807 .807 .742 .666 .558 .468
4.2 Performance as a Kernel Function Question Classification
The comparison methods were evaluated the performance as a kernel function in the machine learning approach of the Question Classification. We chose SVM as a kernel-based learning algorithm that produces state-of-the-art performance in several NLP tasks.
We used the same data set as used in the previous experiments with the following difference: if a question type had fewer than ten questions, we moved the entries into the upper question type as defined in CRL-QA data to provide enough training samples for each question type. We used one-vs-rest as the multi-class classification method and found a highest scoring question type. In the case of BOA and BOA’, we used the polynomial kernel (Vapnik, 1995) to consider the attribute combinations.
Table 5 shows the average accuracy of each question as evaluated by 5-fold cross validation.
5 Discussion
The experiments in this paper were designed to evaluated how the similarity measure reflects the semantic information of texts. In the task of Question Classification, a given question is classified into Question Type, which reflects the intention of the question. The Sentence Alignment task evaluates which sentence is the most semantically similar to a given sentence.
The HDAG Kernel showed the best performance in the experiments as a similarity measure and as a kernel of the learning algorithm. This proves the usefulness of the HDAG Kernel in determining the similarity measure of texts and in providing an SVM kernel for resolving classification problems in NLP tasks. These results indicate that our approach, incorporating richer structures within texts, is well suited to the tasks that require evaluation of the semantical similarity between texts. The potential use of the HDAG Kernel is very wider in NLP tasks, and we believe it will be adopted in other practical NLP applications such as Text Categorization and Question Answering.
Our experiments indicate that the optimal parameters of combination number  and decay factor  depend the task at hand. They can be determined by experiments.
The original DSK requires exact matching of the tree structure, even when expanded (DSK’) for flexible matching. This is why DSK’ showed the worst performance. Moreover, in Sentence Alignment task, paraphrasing or different expressions with the same meaning is common, and the structures of the parse tree widely differ in general. Unlike DSK’, SSK’ and HDAG Kernel offer approximate matching which produces better performance.
The structure of HDAG approaches that of DAG, if we do not consider the hierarchical structure. In addition, the structure of sequences (strings) is entirely included in that of DAG. Thus, the framework of the HDAG Kernel covers DAG Kernel and SSK.
6 Conclusion
This paper proposed the HDAG Kernel, which can reflect the richer information present within texts. Our proposed method is a very generalized framework for handling the structure inside a text.
We evaluated the performance of the HDAG Kernel both as a similarity measure and as a kernel function. Our experiments showed that HDAG Kernel offers better performance than SSK, DSK, and the baseline method of the Cosine measure for feature vectors, because HDAG Kernel better utilizes the richer structure present within texts.
