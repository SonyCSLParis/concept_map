1 Introduction In this paper, we present a block-based model for statistical machine translation. A block is a pair of phrases which are translations of each other. For example, Fig. 1 shows an Arabic-English translation example that uses � blocks. During decoding, we view translation as a block segmentation process, where the input sentence is segmented from left to right and the target sentence is generated from bottom to top, one block at a time. A monotone block sequence is generated except for the possibility to swap a pair of neighbor blocks. We use an orientation model similar to the lexicalized block re-ordering model in (Tillmann, 2004; Och et al., 2004): to generate a block with orientation relative to its predecessor block �� . During decoding, we compute the probability �� �� ��� � ���
��
�
�
�
�
�
���
�
���
"D
"E
GF
Figure 1: An Arabic-English block translation example, where the Arabic words are romanized. The following orientation sequence is generated:
�IHKJ
� eft ���
Q
� eutral �6W is a three-valued orientation component linked to the block � (the orientation ��ﬃ � of the predecessor block is currently ignored.). Here, the block sequence with orientation �
X�
�
�
�
�
� is generated under the restriction that the concatenated source phrases of the blocks � yield the input sentence. In modeling a block sequence, we emphasize adjacent block neighbors that have Right or Left orientation. Blocks with neutral orientation are supposed to be less strongly ’linked’ to their predecessor block and are handled separately. During decoding, most blocks have right orientation ��
HYQ
The focus of this paper is to investigate issues in discriminative training of decoder parameters. Instead of directly minimizing error as in earlier work (Och, 2003), we decompose the decoding process into a sequence of local decision steps based on Eq. 1, and then train each local decision rule using convex optimization techniques. The advantage of this approach is that it can easily handle a large amount of features. Moreover, under this view, SMT becomes quite similar to sequential natural language annotation problems such as part-of-speech tagging, phrase chunking, and shallow parsing. The paper is structured as follows: Section 2 introduces the concept of block orientation bigrams. Section 3 describes details of the localized log-linear prediction model used in this paper. Section 4 describes the online training procedure and compares it to the well known perceptron training algorithm (Collins, 2002). Section 5 shows experimental results on an Arabic-English translation task. Section 6 presents a final discussion.
2 Block Orientation Bigrams This section describes a phrase-based model for SMT similar to the models presented in (Koehn et al., 2003; Och et al., 1999; Tillmann and Xia, 2003). In our paper, phrase pairs are named blocks and our model is designed to generate block sequences. We also model the position of blocks relative to each other: this is called orientation. To define block sequences with orientation, we define the notion of block orientation bigrams. Starting point for collecting these bigrams is a block set Z
H
H
�V[
�V\]�
H
�V^�_
. Here, is a block consisting of a source phrase [ and a target phrase \ . e is the source phrase length and f is the target phrase length. Single source and target words are denoted by ^�g and a
� respectively, where h H f .
We will also use a special single-word block set Z �`l
Z f
H
� . For the experiments in this paper, the block set is the one used in (Al-Onaizan et al., 2004). Although this is not investigated in the present paper, different blocksets may be used for computing the block statistics introduced in this paper, which may effect translation results.
��
\
� are adjacent. �� is predecessor of block if �� and are adjacent and �� occurs below . A right adjacent successor block is said to have right orientation
HmQ
.
A left adjacent successor block is said to have left orientab b'
. The successor block or right
HQ orientation. ’left’ and ’right’ are defined relative to the  axis ; ’below’ is defined relative to the  axis. For some discussion on global re-ordering see Section 6.
tion H
N
. There are matching blocks that have no predecessor, such a block has neutral orientation ( HYJ ). After matching blocks for a training sentence pair, we look for adjacent block pairs to collect block bigram orientation events  of the type 
H
�k k�
��
�
. In Fig. 1, the following block orientation bigrams occur: � i�
J
�k
�


�
� (2)
Here,   is the number of orientation bigrams in the ^ -th sentence pair. The total number
J


�
�


HM"" sentence pairs. The orientation bigram list is used for the parameter training presented in Section 3. Ignoring the bigrams with neutral orientation
J
�
 million orientation bigrams. The Neutral orientation is handled separately as described in Section 5. Using the reduced orientation bigram list, we collect unigram orientation counts
J d�
: how often a block occurs with a given orientation RT
N
ﬀ k�G�

�
�+ k� or type � ��¤�
Q
�+ k�
R
�
. The average size of £"� 6�V� is �r�  successor blocks. If we were to compute a Viterbi block alignment for a training sentence pair, each block in this block alignment would have at most � successor: Blocks may have several successors, because we do not inforce any kind of consistent coverage during training.
During decoding, we generate a list of block orientation bigrams as described above. A DP-based beam search procedure identical to the one used in (Tillmann, 2004) is used to maximize over all oriented block segmentations �
X� � �
� �
�
3 Localized Block Model and Discriminative Training
In this section, we describe the components used to compute the block bigram probability
ﬀ
�
�
��
R« ¬
. For a model that uses all the components defined below, ­ is � . As featurevector components, we take the negative logarithm of some block model probabilities. We use the term ’float’ feature for these feature-vector components (the model score is stored as a float number). Additionally, we use binary block features. The letters (a)-(f) refer to Table 1:
Unigram Models: we compute (a) the unigram probability
ﬀ

�
.
These probabilities are simple relative frequency estimates based on unigram and unigram orientation counts derived from the data in Eq. 2. For details see (Tillmann, 2004). During decoding, the unigram probability is normalized by the source phrase length.
Two types of Trigram language model: (c) probability of predicting the first target word in the target clump of
� given the final two words of the target clump of
�¤ﬃ
�
, (d) probability of predicting the rest of the words in the target clump of � . The language model is trained on a separate corpus.
Lexical Weighting: (e) the lexical weight ﬀ
��[
�V\]� is computed similarly to (Koehn et al., 2003), details are given in Section 3.4.
Binary features: (f) binary features are defined using an indicator function ©ª�
+�+ ��V�
��+ ��V�
J else (3)
�� � �
� �
�
^
�
��
�
�
�
�
W
��
�
�
�
�
�
�
�
�
�
� denotes the feature vector of the corresponding block translation, and the partition function is:
¹
�V^
�
� can be rather difficult to compute. Consequently some sophisticated approximate inference methods are needed to carry out the computation. A detailed investigation of the global model will be left to another study.
3.2 Local Model Restrictions In the following, we consider a simplification of the direct global model in Eq. 4. As in (Tillmann, 2004), we model the block bigram probability as
ﬀ
�
� in Eq. 1. We distinguish the two cases (1) �SRÇT N � Q W , and (2) � HKJ . Orientation is modeled only in the context of immediate neighbors for blocks that have left or right orientation. The log-linear model is defined as:
ﬀ
¨M ��¤�
�V�
+�
�
�§�
�
�
�
�
¨
^
�
�§¨
^
� is a restricted set of possible successor oriented blocks that are consistent with the current block position and the source sentence ^ , to be described in the following paragraph. Note that a straightforward normalization over all block orientation pairs in Eq. 5 is not feasible: there are tens of millions of possible successor blocks
(if we do not impose any restriction). For each block
H
�V[
��\]�
�
ÆW contains the block
�
�
�� �V�
�
�
,
�
� k� are single word blocks. The partition function is computed slightly differently during training and decoding:
Training: for each event � ��¤�
�+ d�

�
��§�
. This defines a set of ’true’ block successors. For each true successor
, we compute the alternative set Z
� is the union of the alternative set for each successor
. Here, the orientation from the true successor is assigned to each alternative in Z � k�
.
6���
�+ k� in the list � � .
Decoding: Here, each block that matches a source interval following
6�
�
�
�
¨
^
�
Z
� k� just restricts the possible target translations for a source phrase.
Under this model, the log-probability of a possible translation of a source sentence ^ , as in Eq. 1, can be written as
Ì¿Í
�
¨
^
� �
In the maximum-likelihood training, we find ± by maximizing the sum of the log-likelihood over observed sentences, each of them has the form in Eq. 7. Although the training methodology is similar to the global formulation given in Eq. 4, this localized version is computationally much easier to manage since the summation in the partition function ¹ �
��ﬃ
�
¨
^
� is now over a relatively small set of candidates. This computational advantage is the main reason that we adopt the local model in this paper.
3.3 Global versus Local Models Both the global and the localized log-linear models described in this section can be considered as maximumentropy models, similar to those used in natural language processing, e.g. maximum-entropy models for POS tagging and shallow parsing. In the parsing context, global models such as in Eq. 4 are sometimes referred to as conditional random field or CRF (Lafferty et al., 2001).
Although there are some arguments that indicate that this approach has some advantages over localized models such as Eq. 5, the potential improvements are relatively small, at least in NLP applications. For SMT, the difference can be potentially more significant. This is because in our current localized model, successor blocks of different sizes are directly compared to each other, which is intuitively not the best approach (i.e., probabilities of blocks with identical lengths are more comparable). This issue is closely related to the phenomenon of multiple counting of events, which means that a source/target sentence pair can be decomposed into different oriented blocks in our model. In our current training procedure, we select one as the truth, while consider the other (possibly also correct) decisions as non-truth alternatives. In the global modeling, with appropriate normalization, this issue becomes less severe. With this limitation in mind, the localized model proposed here is still an effective approach, as demonstrated by our experiments. Moreover, it is simple both computationally and conceptually. Various issues such as the ones described above can be addressed with more sophisticated modeling techniques, which we shall be left to future studies.
3.4 Lexical Weighting The lexical weight
ﬀ
�V\]� is computed similarly to (Koehn et al., 2003), but the lexical translation probability
ﬀ
ﬂ ad� is derived from the block set itself rather than from a word alignment, resulting in a simplified training. The lexical weight is computed as follows:
ﬀ
��^�g
ﬂ a
H
��^�g
�Va and ��
H
��^Mg
��aXÐ.� are single-word blocks, where source and target phrases are of length � .
J
Î
Ð
H f for which ﬀ
4 Online Training of Maximum-entropy Model
The local model described in Section 3 leads to the following abstract maximum entropy training formulation:
Ò
� � (8)
��¤�
^
�
��
¨M ��¤�
�V�
. This formulation is slightly different from the standard maximum entropy formulation typically encountered in NLP applications, in that we restrict the summation over a subset ² � of all labels. Intuitively, this method favors a weight vector such that for each j , ±¸  � ¾ ÜkÚ(Þ ±¸  � ¾ g is large when hUß
H

�
. This effect is desirable since it tries to separate the correct classification from the incorrect alternatives. If the problem is completely separable, then it can be shown that the computed linear separator, with appropriate regularization, achieves the largest possible separating margin. The effect is similar to some multi-category generalizations of support vector machines (SVM). However, Eq. 8 is more suitable for non-separable problems (which is often the case for SMT) since it directly models the conditional probability for the candidate labels.
� when ±¸ �¿ � ¾ ÜkÚªÞ  � ¾ g �
� is the smallest. It can be shown that if there exist weight vectors that separate the correct label  � from incorrect labels h R ² � for all hUß
H

�
, then the perceptron method can find such a separator. However, it is not entirely clear what this method does when the training data are not completely separable. Moreover, the standard mistake bound justification does not apply when we go through the training data more than once, as typically done in practice. In spite of some issues in its justification, the perceptron algorithm is still very attractive due to its simplicity and computational efficiency. It also works quite well for a number of NLP applications.
In the following, we show that a simple and efficient online training procedure can also be developed for the maximum entropy formulation Eq. 8. The proposed update rule is similar to the perceptron method but with a soft mistake-driven update rule, where the influence of each feature is weighted by the significance of its mistake. The method is essentially a version of the socalled stochastic gradient descent method, which has been widely used in complicated stochastic optimization problems such as neural networks. It was argued recently in (Zhang, 2004) that this method also works well for standard convex formulations of binary-classification problems including SVM and logistic regression. Convergence bounds similar to perceptron mistake bounds can be developed, although unlike perceptron, the theory justifies the standard practice of going through the training data more than once. In the non-separable case, the method solves a regularized version of Eq. 8, which has the statistical interpretation of estimating the conditional probability. Consequently, it does not have the potential issues of the perceptron method which we pointed out earlier. Due to the nature of online update, just like perceptron, this method is also very simple to implement and is scalable to large problem size. This is important in the SMT application because we can have a huge number of training instances which we are not able to keep in memory at the same time.
In stochastic gradient descent, we examine one training instance at a time. At the j -th instance, we derive the update rule by maximizing with respect to the term associated with the instance
N
� in Eq. 8. We do a gradient descent localized to this instance as ±ãàä± Þæå �`ç
ç
Ù
N
 is a parameter often referred to as the learning rate. For Eq. 8, the update rule becomes:
±áàâ±
� (9)
Similar to online algorithms such as the perceptron, we apply this update rule one by one to each training instance (randomly ordered), and may go-through data points repeatedly. Compare Eq. 9 to the perceptron update, there are two main differences, which we discuss below.
The first difference is the weighting scheme. Instead of putting the update weight to a single (most mistaken) feature component, as in the perceptron algorithm, we use a soft-weighting scheme, with each feature component h weighted by a factor ´+¶· � ±p¸  � ¾ g
��è
Ð
ÁdÂ
Ú
´k¶·
�
. A component h with larger ±p¸  � ¾ g gets more weight. This effect is in principle similar to the perceptron update. The smoothing effect in Eq. 9 is useful for non-separable problems since it does not force an update rule that attempts to separate the data. Each feature component gets a weight that is proportional to its conditional probability.
The second difference is the introduction of a learning rate parameter å � . For the algorithm to converge, one should pick a decreasing learning rate. In practice, however, it is often more convenient to select a fixed å �
H
å for all j . This leads to an algorithm that approximately solve a regularized version of Eq. 8. If we go through the data repeatedly, one may also decrease the fixed learning rate by monitoring the progress made each time we go through the data. For practical purposes, a fixed small å such as å
H
ﬃ.é is usually sufficient. We typically run forty updates over the training data. Using techniques similar to those of (Zhang, 2004), we can obtain a convergence theorem for our algorithm. Due to the space limitation, we will not present the analysis here.
An advantage of this method over standard maximum entropy training such as GIS (generalized iterative scaling) is that it does not require us to store all the data in memory at once. Moreover, the convergence analysis can be used to show that if ê is large, we can get a very good approximate solution by going through the data only once. This desirable property implies that the method is particularly suitable for large scale problems.

�


 sentences with �M� b
 and filter the parallel training data to include only those training sentence pairs that contain at least one out of these phrases: the ’LDC’ training data contains about
bM thousand sentence pairs and the ’MT03’ training data contains about
Õ" thousand sentence pairs. Two block sets are derived for each of the training sets using a phrase-pair selection algorithm similar to (Koehn et al., 2003; Tillmann and Xia, 2003). These block sets also include blocks that occur only once in the training data.
Additionally, some heuristic filtering is used to increase phrase translation accuracy (Al-Onaizan et al., 2004).
 uses the same two features, but neighbor blocks can be swapped. No performance increase is obtained for this model. The ’SWAP & OR’ model uses an orientation model as described in Section 3. Here, we obtain a small but significant improvement over the baseline model. Line � shows that by including two additional ’float’ features: the lexical weighting and the language model probability of predicting the second and subsequent words of the target clump yields a further significant improvement. Line  shows that including binary features and training their weights on the training data actually decreases performance. This issue is addressed in Section 5.2.


�
b million features of the type defined in Eq. 3 by setting the threshold
JëHì


HãJ
���
��­
���
��
�
, but not � k� and �V© � . Here, the neutral model is trained on the neutral orientation bigram subsequence that is part of Eq. 2.
5.2 Modified Weight Training We implemented the following variation of the likelihood training procedure described in Section 3, where we make use of the ’LDC’ devtest set. First, we train a model on the ’LDC’ training data using  float features and the binary features. We use this model to decode
Table 1: List of feature-vector components. For a description, see Section 3.
Description (a) Unigram probability (b) Orientation probability (c) LM first word probability (d) LM second and following words probability (e) Lexical weighting (f) Binary Block Bigram Features
Table 2: Cased BLEU translation results with confidence intervals on the MT03 test data. The third column summarizes the model variations. The results in lines � and Ê are for a cheating experiment: the float weights are trained on the test data itself.
Re-ordering Components BLEU 1 ’MON’ (a),(c) " � pï �G�  2 ’SWAP’ (a),(c) " � pï �G�  3 ’SWAP & OR’ (a),(b),(c) " � Ê ï �G� � 4 ’SWAP & OR’ (a)-(e)  � ðï �G�  5 ’SWAP & OR’ (a)-(f)  � pï �G� � 6 ’SWAP & OR’ (a)-(e) (ldc devtest)  � � ï �G�  7 ’SWAP & OR’ (a)-(f) (ldc devtest)  ��� pï �G�  8 ’SWAP & OR’ (a)-(e) (mt03 test)  Ê�� pï �G�  9 ’SWAP & OR’ (a)-(f) (mt03 test)  Ê�� pï �G� � the devtest ’LDC’ set. During decoding, we generate a ’translation graph’ for every input sentence using a procedure similar to (Ueffing et al., 2002): a translation graph is a compact way of representing candidate translations which are close in terms of likelihood. From the translation graph, we obtain the �
Õ"



�
�
""
-best list. The  float weights are trained on the modified training data in Eq. 10, where the training takes only a few seconds. We then decode the ’MT03’ test set using the modified ’float’ weights. As shown in line � and line � there is almost no change in performance between training on the original training data in Eq. 2 or on the modified training data in Eq. 10. Line
� shows that even when training the float weights on an event set obtained from the test data itself in a cheating experiment, we obtain only a moderate performance improvement from
b
 and Ê , we use the same five float weights as trained for the experiments in line � and � and keep them fixed while training the binary feature weights only. Using the binary features leads to only a minor improvement in BLEU from
b
� � to  in line 
. For this best model, we obtain a �M�ñ� � % BLEU improvement over the baseline.
From our experimental results, we draw the following conclusions: (1) the translation performance is largely dominated by the ’float’ features, (2) using the same set of ’float’ features, the performance doesn’t change much when training on training, devtest, or even test data. Although, we do not obtain a significant improvement from the use of binary features, currently, we expect the use of binary features to be a promising approach for the following reasons: ò The current training does not take into account the block interaction on the sentence level. A more accurate approximation of the global model as discussed in Section 3.1 might improve performance.
ò As described in Section 3.2 and Section 5.2, for efficiency reasons alternatives are computed from source phrase matches only. During training, more accurate local approximations for the partition function in Eq. 6 can be obtained by looking at block translations in the context of translation sequences. This involves the computationally expensive generation of a translation graph for each training sentence pair. This is future work.
ò As mentioned in Section 1, viewing the translation process as a sequence of local discussions makes it similar to other NLP problems such as POS tagging, phrase chunking, and also statistical parsing. This similarity may facilitate the incorporation of these approaches into our translation model.
6 Discussion and Future Work In this paper we proposed a method for discriminatively training the parameters of a block SMT decoder. We discussed two possible approaches: global versus local. This work focused on the latter, due to its computational advantages. Some limitations of our approach have also been pointed out, although our experiments showed that this simple method can significantly improve the baseline model.
As far as the log-linear combination of float features is concerned, similar training procedures have been proposed in (Och, 2003). This paper reports the use of � features whose parameter are trained to optimize performance in terms of different evaluation criteria, e.g. BLEU. On the contrary, our paper shows that a significant improvement can also be obtained using a likelihood training criterion.
Our modified training procedure is related to the discriminative re-ranking procedure presented in (Shen et al., 2004). In fact, one may view discriminative reranking as a simplification of the global model we discussed, in that it restricts the number of candidate global translations to make the computation more manageable. However, the number of possible translations is often exponential in the sentence length, while the number of candidates in a typically reranking approach is fixed. Unless one employs an elaborated procedure, the candidate translations may also be very similar to one another, and thus do not give a good coverage of representative translations. Therefore the reranking approach may have some severe limitations which need to be addressed. For this reason, we think that a more principled treatment of global modeling can potentially lead to further performance improvements.
For future work, our training technique may be used to train models that handle global sentence-level reorderings. This might be achieved by introducing orientation sequences over phrase types that have been used in ((Schafer and Yarowsky, 2003)). To incorporate syntactic knowledge into the block-based model, we will examine the use of additional real-valued or binary features, e.g. features that look at whether the block phrases cross syntactic boundaries. This can be done with only minor modifications to our training method.
Acknowledgment This work was partially supported by DARPA and monitored by SPAWAR under contract No. N66001-99-2- 8916. The paper has greatly profited from suggestions by the anonymous reviewers.
